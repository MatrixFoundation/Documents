---
sidebar_label: C# è¿›é˜¶æå‡
title: C# è¿›é˜¶æå‡
sidebar_position: 4
---

## ä¸€ã€æ–¹æ³• ğŸ“

åœ¨ `C#` ä¸­ï¼Œæ–¹æ³•æ˜¯æ‰§è¡Œç‰¹å®šä»»åŠ¡çš„ä»£ç å—ï¼Œå¯ä»¥ä»ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†è°ƒç”¨ã€‚æ–¹æ³•å¯ä¿ƒè¿›ä»£ç é‡ç”¨ã€å¯è¯»æ€§å’Œæ¨¡å—åŒ–ã€‚

### 1ã€æ–¹æ³•å£°æ˜ ğŸ“

```csharp
public class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }
}
```

åŸºæœ¬ç»„æˆéƒ¨åˆ†ï¼š

- è®¿é—®ä¿®é¥°ç¬¦ï¼ˆå¦‚ `public`, `private`ï¼‰
- è¿”å›ç±»å‹ï¼ˆå¦‚ `void`, `int`, `string` ç­‰ï¼‰
- æ–¹æ³•åï¼ˆä½¿ç”¨é©¼å³°å‘½åæ³•ï¼‰
- å‚æ•°åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰

### 2ã€è°ƒç”¨æ–¹æ³• ğŸ”—

#### å®ä¾‹æ–¹æ³•è°ƒç”¨

```csharp
Calculator calculator = new Calculator();
int result = calculator.Add(1, 2);
Console.WriteLine(result);
```

#### é™æ€æ–¹æ³•è°ƒç”¨

```csharp
public class MathHelper
{
    public static int Square(int x)
    {
        return x * x;
    }
}

// Call directly using the class name
int result = MathHelper.Square(4);  // result = 16
```

### 3ã€æ–¹æ³•é‡è½½ ğŸ”„

1. æ–¹æ³•åç§°å¿…é¡»ç›¸åŒ
2. å‚æ•°åˆ—è¡¨å¿…é¡»ä¸åŒï¼šå‚æ•°æ•°é‡ä¸åŒã€å‚æ•°ç±»å‹ä¸åŒã€å‚æ•°é¡ºåºä¸åŒ

```csharp
public class Calculator
{
    // Add two integers
    public int Add(int a, int b)
    {
        return a + b;
    }

    // Add two double-precision floating-point numbers
    public double Add(double a, double b)
    {
        return a + b;
    }

    // Add three integers
    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }

    // Different parameter order
    public int Add(int a, string b)
    {
        return a + int.Parse(b);
    }
}
```

### 4ã€æ–¹æ³•å‚æ•° ğŸ“Œ

#### å¿…éœ€å‚æ•°

```csharp
public class MathOperations
{
    public int Multiply(int x, int y)
    {
        return x * y;
    }
}
```

#### å¯é€‰å‚æ•°

å¯é€‰å‚æ•°æä¾›äº†ä¸€ç§ç®€æ´çš„æ–¹æ³•æ¥å¤„ç†å…·æœ‰é»˜è®¤è¡Œä¸ºçš„æ–¹æ³•è°ƒç”¨ï¼Œå…¶å¿…é¡»åœ¨å¿…å¡«å‚æ•°ä¹‹åã€‚

```csharp
public class Printer
{
    // Optional parameter with a default value
    public void PrintMessage(string message, bool uppercase = false)
    {
        if (uppercase)
        {
            Console.WriteLine(message.ToUpper());
        }
        else
        {
            Console.WriteLine(message);
        }
	}
}
```

#### å€¼å‚æ•°ï¼ˆé»˜è®¤ï¼‰

```csharp
void ModifyValue(int x)
{
    x = 10;  // Will not change the original value
}
```

#### å¼•ç”¨å‚æ•°ï¼ˆ`ref`ï¼‰

```csharp
void ModifyReference(ref int x)
{
    x = 10;  // Will change the original value
}

int number = 5;
ModifyReference(ref number);  // number is now 10
```

#### è¾“å‡ºå‚æ•°ï¼ˆ`out`ï¼‰

æä¾›ä¸€ç§ç®€æ´çš„å¤šè¿”å›å€¼æœºåˆ¶ï¼Œç‰¹åˆ«é€‚åˆéœ€è¦åŒæ—¶è¿”å›çŠ¶æ€å’Œç»“æœçš„åœºæ™¯ã€‚

```csharp
public class UserValidator
{
    // Validate user information
    public bool ValidateUser(string input, out int userId, out string errorMessage)
    {
        userId = -1;
        errorMessage = "";

        // Parse user ID
        if (!int.TryParse(input, out userId))
        {
            errorMessage = "Invalid user ID format";
            return false;
        }

        // Check ID range
        if (userId <= 0)
        {
            errorMessage = "User ID must be greater than 0";
            return false;
        }

        return true;
    }
}

public void ProcessUser()
{
    UserValidator validator = new UserValidator();

    // Call the method
    bool isValid = validator.ValidateUser("123", out int userId, out string message);

    if (isValid)
    {
        Console.WriteLine($"User ID: {userId}");
    }
    else
    {
        Console.WriteLine($"Validation failed: {message}");
    }
}
```

#### å‚æ•°æ•°ç»„ï¼ˆ`params`ï¼‰

```csharp
public int Sum(params int[] numbers)
{
    int total = 0;
    foreach(int num in numbers)
        total += num;
    return total;
}
```

### 5ã€è¿”å›ç±»å‹ ğŸ“¤

#### æœ‰è¿”å›å€¼çš„æ–¹æ³•

```csharp
public class Circle
{
    public double CalculateArea(double radius)
    {
        return Math.PI * radius * radius;
    }
}
```

#### ç©ºæ–¹æ³•

```csharp
public class Logger
{
    public void LogError(string errorMessage)
    {
        Console.WriteLine($"Error: {errorMessage}");
    }
}
```

## äºŒã€é¢å‘å¯¹è±¡ç¼–ç¨‹ ğŸ“¦

### 1ã€åŸåˆ™ ğŸ“

é¢å‘å¯¹è±¡ç¼–ç¨‹åŸºäºå››ä¸ªä¸»è¦åŸåˆ™ï¼šå°è£…ã€ç»§æ‰¿ã€å¤šæ€æ€§å’ŒæŠ½è±¡ã€‚

- å°è£…å…è®¸å°†æ•°æ®å’Œæ–¹æ³•æ†ç»‘åˆ°ä¸€ä¸ªå•å…ƒï¼ˆç±»ï¼‰ä¸­å¹¶é™åˆ¶è®¿é—®åˆ°æŸäº›ç»„ä»¶ã€‚
- ç»§æ‰¿å…è®¸ä¸€ä¸ªç±»ï¼ˆå­ç±»æˆ–æ´¾ç”Ÿç±»ï¼‰ç»§æ‰¿å¦ä¸€ç±»ï¼ˆçˆ¶ç±»æˆ–åŸºç±»ï¼‰çš„å±æ€§å’Œæ–¹æ³•ã€‚è¿™ä¿ƒè¿›äº†ä»£ç çš„é‡ç”¨å¹¶åœ¨ç±»ä¹‹é—´å»ºç«‹äº†å±‚æ¬¡å…³ç³»ã€‚
- å¤šæ€æ€§æ˜¯å•ä¸ªå‡½æ•°æˆ–æ–¹æ³•æ ¹æ®å…¶è¾“å…¥æˆ–è°ƒç”¨å®ƒçš„å¯¹è±¡ä»¥å„ç§æ–¹å¼å·¥ä½œçš„èƒ½åŠ›ã€‚åœ¨`C#`ä¸­ï¼Œå¤šæ€æ€§å¯ä»¥é€šè¿‡æ–¹æ³•è¦†ç›–ï¼ˆä½¿ç”¨`override`å…³é”®å­—ï¼‰å’Œæ–¹æ³•éšè—ï¼ˆåˆ©ç”¨`new`å…³é”®å­—éšè—åŸºç±»ä¸­çš„æ–¹æ³•ï¼‰æ¥å®ç°ã€‚
- æŠ½è±¡å…è®¸å¼€å‘äººå‘˜éšè—å¤æ‚çš„å®ç°å¹¶ä»…æ˜¾ç¤ºå¯¹è±¡çš„åŸºæœ¬ç‰¹å¾ã€‚è¿™æ„å‘³ç€ç”¨æˆ·ä»…ä¸å¿…è¦çš„å†…å®¹è¿›è¡Œäº¤äº’ï¼Œå¹¶ä¸”å†…éƒ¨è¿ä½œä¿æŒéšè—ã€‚åœ¨`C#`ä¸­ï¼ŒæŠ½è±¡ç±»å’Œæ¥å£æ˜¯å¯ä»¥å¸®åŠ©å®ç°æŠ½è±¡çš„å·¥å…·ã€‚

è¿™äº›åŸåˆ™æœ‰åŠ©äºè®¾è®¡å¼ºå¤§ä¸”å¯æ‰©å±•çš„åº”ç”¨ç¨‹åºï¼Œä»è€Œæ˜“äºç»´æŠ¤å’Œè¿›ä¸€æ­¥å¼€å‘ã€‚

#### å°è£…å’ŒæŠ½è±¡

è¿™äº›æ¦‚å¿µæœ‰åŠ©äºç®¡ç†å¯¹å¯¹è±¡æ•°æ®çš„è®¿é—®å¹¶åœ¨ç¼–ç¨‹ä¸­å®ç°é«˜çº§æŠ½è±¡ï¼š

- å°è£…ä¿æŠ¤å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€å¹¶é˜²æ­¢æœªç»æˆæƒçš„å¤–éƒ¨è®¿é—®ï¼Œå…è®¸ä¸¥æ ¼æ§åˆ¶æ•°æ®å¹¶ç¡®ä¿æ•°æ®å®Œæ•´æ€§ã€‚
- æŠ½è±¡å…è®¸å®ç°ä¸æ¥å£åˆ†ç¦»ï¼Œå¹¶æ”¯æŒåˆ›å»ºå…·æœ‰æ›´é«˜çµæ´»æ€§å’Œå¯æ‰©å±•æ€§çš„ç³»ç»Ÿï¼Œä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿé™ä½ç¼–ç¨‹å¤æ‚æ€§å¹¶æé«˜æ•ˆç‡ã€‚

åœ¨ `C#` ä¸­ï¼Œé€šè¿‡ `private`ã€`protected` å’Œ `public` ç­‰è®¿é—®ä¿®é¥°ç¬¦æ¥ç¡®ä¿å°è£…ã€‚

è¿™äº›ä¿®é¥°ç¬¦å†³å®šç±»æˆå‘˜çš„å¯è§æ€§ï¼Œå…è®¸éšè—å®ç°ç»†èŠ‚å¹¶ä»…å…¬å¼€å¿…è¦çš„ APIã€‚

- `public`: å®Œå…¨è®¿é—®
- `private`: ä»…åœ¨ç±»å†…éƒ¨è®¿é—®
- `protected`: ç±»å†…éƒ¨å’Œæ´¾ç”Ÿç±»å¯è®¿é—®
- `internal`: åŒä¸€ç¨‹åºé›†å†…å¯è®¿é—®

| ä¿®é¥°ç¬¦             | åŒä¸€ç±»ä¸­ | åŒä¸€ç¨‹åºé›†å†…<br />æ´¾ç”Ÿç±»ä¸­ | åŒä¸€ç¨‹åºé›†å†…<br />éæ´¾ç”Ÿç±»ä¸­ | ä¸åŒç¨‹åºé›†å†…<br />æ´¾ç”Ÿç±»ä¸­ | ä¸åŒç¨‹åºé›†å†…<br />éæ´¾ç”Ÿç±»ä¸­ |
| ------------------ | -------- | -------------------------- | ---------------------------- | -------------------------- | ---------------------------- |
| public             | âœ”ï¸       | âœ”ï¸                         | âœ”ï¸                           | âœ”ï¸                         | âœ”ï¸                           |
| private            | âœ”ï¸       | âŒ                         | âŒ                           | âŒ                         | âŒ                           |
| protected          | âœ”ï¸       | âœ”ï¸                         | âŒ                           | âœ”ï¸                         | âŒ                           |
| internal           | âœ”ï¸       | âœ”ï¸                         | âœ”ï¸                           | âŒ                         | âŒ                           |
| protected internal | âœ”ï¸       | âœ”ï¸                         | âœ”ï¸                           | âœ”ï¸                         | âŒ                           |
| private protected  | âœ”ï¸       | âœ”ï¸                         | âŒ                           | âŒ                         | âŒ                           |

#### ç»§æ‰¿å’Œå¤šæ€æ€§

ç»§æ‰¿å’Œå¤šæ€æ€§æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹çš„å…³é”®åŸåˆ™ï¼Œå¯ç¡®ä¿ä»£ç çš„å¯é‡ç”¨æ€§å’Œçµæ´»æ€§ï¼š

- ç»§æ‰¿å…è®¸åˆ›å»ºä¸€ä¸ªæ–°ç±»ï¼Œè¯¥ç±»ç»§æ‰¿ç°æœ‰ç±»çš„å±æ€§å’Œæ–¹æ³•ï¼Œä»è€Œæé«˜ä»£ç å¯é‡ç”¨æ€§å¹¶åœ¨ç±»ä¹‹é—´å»ºç«‹å±‚æ¬¡å…³ç³»ã€‚
- å¤šæ€æ€§æ˜¯é€šè¿‡ä½¿ç”¨ `virtual` å’Œ `override` å…³é”®å­—é‡å†™å­ç±»ä¸­çš„æ–¹æ³•çš„èƒ½åŠ›ä»¥åŠé€šè¿‡å…è®¸ä¸åŒçš„ç±»æ‹¥æœ‰ä¸€ç»„ä¸€è‡´çš„æ–¹æ³•çš„æ¥å£æ¥å®ç°çš„ã€‚

### 2ã€ç±»ä¸å¯¹è±¡ ğŸ“

ç±»å’Œå¯¹è±¡æ˜¯ `C#` ä¸­é¢å‘å¯¹è±¡ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µã€‚ç±»æ˜¯ä¸€ä¸ªç”¨æˆ·è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œå®ƒå°è£…äº†æ•°æ®å’Œæ“ä½œæ•°æ®çš„æ–¹æ³•ã€‚å¯¹è±¡æ˜¯ç±»çš„ç‰¹å®šå®ä¾‹ï¼Œä»£è¡¨å·²å®šä¹‰ç±»çš„å®ç°ã€‚

#### ç±»çš„åŸºç¡€

:::tip

é»˜è®¤è®¿é—®ä¿®é¥°ç¬¦æ˜¯ `internal`ï¼Œæˆå‘˜çš„é»˜è®¤è®¿é—®ä¿®é¥°ç¬¦æ˜¯ `private`ã€‚

:::

```csharp
public class Character
{
    // Properties
    public string Name { get; set; }
    public int Level { get; set; }
    public int Health { get; set; }

    // Constructor
    public Character(string name)
    {
        Name = name;
        Level = 1;
        Health = 100;
    }

    // Method
    public void LevelUp()
    {
        Level++;
        Health += 10;
        Console.WriteLine($"{Name} leveled up to level {Level}");
    }

    // Virtual method, can be overridden by subclasses
    public virtual void Introduction()
    {
        Console.WriteLine($"I am {Name}, currently at level {Level}");
    }
}
```

#### å±æ€§

åœ¨ `C#` ä¸­ï¼Œå±æ€§ï¼ˆPropertyï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„æˆå‘˜ï¼Œç”¨äºå°è£…ç±»ä¸­çš„å­—æ®µå¹¶æä¾›å¯¹å…¶çš„è®¿é—®ã€‚å±æ€§ä½¿å¾—å¤–éƒ¨ä»£ç å¯ä»¥åƒè®¿é—®å­—æ®µä¸€æ ·è®¿é—®ç±»çš„å†…éƒ¨æ•°æ®ï¼Œä½†é€šè¿‡å±æ€§çš„æ–¹å¼å¯ä»¥å¢åŠ ä»£ç çš„å®‰å…¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

å±æ€§é€šå¸¸ç”±ä¸¤ä¸ªè®¿é—®å™¨ï¼ˆAccessorï¼‰ç»„æˆï¼š

- `get`ï¼šç”¨äºè·å–å±æ€§çš„å€¼ã€‚

- `set`ï¼šç”¨äºè®¾ç½®å±æ€§çš„å€¼ã€‚

```csharp
public class Program
{
    public static void Main()
    {
        // Create an instance of the Person class
        Person person = new Person();
        // Use the set accessor to set the Name property
        person.Name = "Jack";
        // Use the get accessor to retrieve the Name property and output it
        Console.WriteLine("Person's name is: " + person.Name);
    }
}

public class Person
{
    private string name;

    public string Name
    {
        get { return name;  }
        set { name = value; }
    }
}
```

<b>è‡ªåŠ¨å±æ€§</b>ï¼šç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªç§æœ‰å­—æ®µæ¥å­˜å‚¨å€¼ã€‚

```csharp
public class Person
{
    public string Name { get; set; }
}
```

<b>åªè¯»å±æ€§</b>
ï¼šåªæœ‰`get`è®¿é—®å™¨ï¼Œæ²¡æœ‰`set`è®¿é—®å™¨ï¼Œåªèƒ½åœ¨æ„é€ å‡½æ•°ä¸­è®¾ç½®ã€‚é€‚ç”¨äºéœ€è¦è®¡ç®—æˆ–åªæä¾›è¯»å–åŠŸèƒ½çš„åœºæ™¯ã€‚

```csharp
public class Circle
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public double Radius
    {
        get { return radius; }
    }

    public double Area
    {
        get { return Math.PI * radius * radius; }
    }
}
```

<b>åªå†™å±æ€§</b>
ï¼šåªæœ‰`set`è®¿é—®å™¨ï¼Œæ²¡æœ‰`get`è®¿é—®å™¨ã€‚é€‚ç”¨äºåªéœ€è¦è®¾ç½®å€¼è€Œä¸éœ€è¦è¯»å–å€¼çš„åœºæ™¯ã€‚

```csharp
public class Account
{
    private decimal balance;

    public decimal Balance
    {
        set { balance = value; }
    }
}
```

<b>åˆå§‹åŒ–å™¨è®¾ç½®</b>ï¼šåœ¨ `C#`
9.0ä¸­ï¼Œå¼•å…¥çš„æ–°ç‰¹æ€§ï¼Œè¿™ä¸€ç‰¹æ€§ä½¿å¾—å±æ€§å¯ä»¥åœ¨å¯¹è±¡åˆå§‹åŒ–æ—¶è¢«èµ‹å€¼ï¼Œä½†ä¸€æ—¦å¯¹è±¡è¢«åˆ›å»ºåï¼Œå±æ€§å°±å˜ä¸ºåªè¯»ï¼Œæ— æ³•å†è¢«ä¿®æ”¹ã€‚è¿™ç§è®¾è®¡æ¨¡å¼ç‰¹åˆ«é€‚åˆäºä¸å¯å˜å¯¹è±¡çš„åˆ›å»ºã€‚

```csharp
public class Program
{
    public static void Main()
    {
        var user = new User
        {
            Username = "Player",
            Email = "player@example.com"
        };
        // user.Username = "Bob"; // This line will cause a compilation error because the Name property is read-only
        Console.WriteLine($"User's Name is: {user.Username}");
        Console.WriteLine($"User's Email is: {user.Email}");
    }
}

public class User
{
    public string Username { get; init; }
    public string Email { get; init; }
}
```

#### æ„é€ å‡½æ•°

æ„é€ å‡½æ•°æ˜¯åˆ›å»ºå¯¹è±¡æ—¶è°ƒç”¨çš„ç‰¹æ®Šæ–¹æ³•ï¼Œå®ƒä»¬åˆå§‹åŒ–å¯¹è±¡çš„çŠ¶æ€ã€‚

<b>é»˜è®¤æ„é€ å‡½æ•°</b>

```csharp
public class Person
{
    public string Name;

    public Person()
    {
        Name = "Player";
    }
}
```

<b>å‚æ•°åŒ–æ„é€ å‡½æ•°</b>

```csharp
public class Book
{
    public string Title;
    public string Author;

    public Book(string title, string author)
    {
        Title = title;
        Author = author;
    }
}
```

#### ææ„å‡½æ•°

ææ„å‡½æ•°ç”¨äºåœ¨å¯¹è±¡ç”Ÿå‘½ç»“æŸæ—¶æ‰§è¡Œæ¸…ç†æ“ä½œï¼Œåœ¨æ¸¸æˆå¼€å‘ä¸­ï¼Œä½¿ç”¨ææ„å‡½æ•°å¯ä»¥å¸®åŠ©ç®¡ç†èµ„æºå’Œå†…å­˜ï¼Œä»¥ç¡®ä¿æ¸¸æˆè¿è¡Œçš„æ•ˆç‡å’Œç¨³å®šæ€§ã€‚

ææ„å‡½æ•°æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ–¹æ³•ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- ä»¥æ³¢æµªç¬¦(~)å¼€å¤´ï¼Œåè·Ÿç±»å
- ä¸èƒ½æœ‰è®¿é—®ä¿®é¥°ç¬¦
- ä¸èƒ½æœ‰å‚æ•°
- ä¸èƒ½æœ‰è¿”å›ç±»å‹
- æ¯ä¸ªç±»åªèƒ½æœ‰ä¸€ä¸ªææ„å‡½æ•°

:::tip

ææ„å‡½æ•°çš„è°ƒç”¨æ—¶é—´æ˜¯ä¸ç¡®å®šçš„ï¼Œå› ä¸ºå®ƒä¾èµ–äºåƒåœ¾å›æ”¶å™¨çš„è¿è¡Œæ—¶æœºã€‚

:::

```csharp
public class Person
{
    public Person()
    {
        Console.WriteLine("Constructor called");
    }

    ~Person()
    {
        Console.WriteLine("Destructor called");
    }
}
```

#### å¯¹è±¡å®ä¾‹åŒ–

åˆ›å»ºç±»çš„å¯¹è±¡æˆ–å®ä¾‹ã€‚

```csharp
// Base class
public class Player
{
    // Properties
    public string Name { get; set; }
    public int Level { get; set; }

    // Parameterless constructor
    public Player()
    {
        Name = "Unnamed Player";
        Level = 1;
    }

    // Constructor with parameters
    public Player(string name)
    {
        Name = name;
        Level = 1;
    }

    // Constructor with multiple parameters
    public Player(string name, int level)
    {
        Name = name;
        Level = level;
    }
}

// Complex object example
public class GameCharacter
{
    // Properties
    public string Name { get; set; }
    public int Health { get; set; }
    public List<string> Skills { get; set; }

    // Constructor
    public GameCharacter()
    {
        Skills = new List<string>();
    }
}

public class Program
{
    public static void Main()
    {
        // 1. The most basic instantiation method
        Player player1 = new Player();

        // 2. Using constructors
        Player player2 = new Player("Hero");
        Player player3 = new Player("Mage", 10);

        // 3. Object initializer
        Player player4 = new Player
        {
            Name = "Archer",
            Level = 5
        };

        // 4. var keyword
        var player5 = new Player("Assassin", 8);

        // 5. Explicit type instantiation
        Player player6 = new("Knight", 12);

        // 6. Collection initialization
        var characters = new List<Player>
        {
            new Player("Warrior"),
            new Player("Mage", 5),
            new Player { Name = "Shooter", Level = 3 }
        };

        // 7. Complex object initialization
        var advancedCharacter = new GameCharacter
        {
            Name = "Ultimate Hero",
            Health = 100,
            Skills = new List<string> { "Fireball", "Heal" }
        };

        // 8. Using factory method
        Player specialPlayer = CreateSpecialPlayer();

        // 9. Nullable type
        Player? optionalPlayer = null;
    }

    // Factory method example
    static Player CreateSpecialPlayer()
    {
        return new Player("Special Character", 20);
    }
}

// Static constructor example
public class GameConfig
{
    // Static field
    public static int MaxLevel { get; private set; }

    // Static constructor: will only be called once
    static GameConfig()
    {
        MaxLevel = 100;
    }
}

// Private constructor (Singleton pattern)
public class GameManager
{
    // Private static instance
    private static GameManager _instance;

    // Private constructor
    private GameManager() { }

    // Public static method to get the instance
    public static GameManager GetInstance()
    {
        if (_instance == null)
        {
            _instance = new GameManager();
        }
        return _instance;
    }
}
```

### 3ã€ç»§æ‰¿ä¸æ´¾ç”Ÿ ğŸ“

#### åŸºç±»ä¸æ´¾ç”Ÿç±»

åŸºç±»ï¼ˆçˆ¶ç±»ï¼‰å®šä¹‰åŸºæœ¬å±æ€§å’Œè¡Œä¸ºï¼Œæ´¾ç”Ÿç±»ï¼ˆå­ç±»ï¼‰ç»§æ‰¿è¿™äº›ç‰¹æ€§å¹¶å¯ä»¥æ·»åŠ è‡ªå·±çš„ç‰¹æ€§ï¼Œä¸€ä¸ªç±»åªèƒ½ç»§æ‰¿è‡ªä¸€ä¸ªåŸºç±»ã€‚

åœ¨ `C#` ä¸­ä½¿ç”¨å†’å·(`:`)æ¥è¡¨ç¤ºç»§æ‰¿å…³ç³»ã€‚

```csharp
// Base class
public class Animal
{
    public string Name { get; set; }
}

// Derived class
public class Dog : Animal
{
    public string Breed { get; set; }
}
```

#### `base` å…³é”®å­—

`base` å…³é”®å­—å…è®¸æ‚¨åœ¨æ´¾ç”Ÿç±»ä¸­è°ƒç”¨åŸºç±»çš„æˆå‘˜ã€‚å®ƒæœ€å¸¸ç”¨äºæ´¾ç”Ÿç±»ä¸­ï¼Œä»¥è°ƒç”¨åŸºç±»çš„æ„é€ å‡½æ•°æˆ–è®¿é—®æ´¾ç”Ÿç±»ä¸­é‡å†™çš„å…¶ä»–åŸºç±»æˆå‘˜ã€‚

```csharp
public class Animal
{
    public virtual void Eat()
    {
        Console.WriteLine("Animal is eating");
    }
}

public class Dog : Animal
{
    public override void Eat()
    {
        // Call base class method
        base.Eat();
        Console.WriteLine("Dog is eating bones");
    }
}
```

#### `this` å…³é”®å­—

`this` å…³é”®å­—æŒ‡å‘è¯¥ç±»çš„å½“å‰å®ä¾‹ã€‚å®ƒé€šå¸¸ç”¨äºæŒ‡å‘å½“å‰å¯¹è±¡çš„å­—æ®µæˆ–æ–¹æ³•ï¼Œç‰¹åˆ«æ˜¯å½“æ–¹æ³•å‚æ•°åç§°ä¸ç±»å­—æ®µåç§°é‡å æ—¶ã€‚

1. å¼•ç”¨å®ä¾‹æˆå‘˜

```csharp
public class Player
{
    private string name;

    public Player(string name)
    {
        // Use the this keyword to reference the member variable name
        this.name = name;
    }

    public void DisplayInfo()
    {
        Console.WriteLine($"Player name: {this.name}");
    }
}
```

2. è°ƒç”¨å…¶ä»–æ„é€ å‡½æ•°

```csharp
public class Character
{
    private string name;
    private int level;

    // Constructor 1
    public Character(string name) : this(name, 1)  // Call Constructor 2
    {

    }

    // Constructor 2
    public Character(string name, int level)
    {
        this.name = name;
        this.level = level;
    }

    public void DisplayInfo()
    {
        Console.WriteLine($"Name: {this.name}, Level: {this.level}");
    }
}
```

#### æ–¹æ³•é‡å†™

- åŸºç±»æ–¹æ³•å¿…é¡»ä½¿ç”¨ `virtual`ã€`abstract` æˆ– `override` å…³é”®å­—æ ‡è®°
- æ´¾ç”Ÿç±»æ–¹æ³•å¿…é¡»ä½¿ç”¨ `override` å…³é”®å­—
- é‡å†™æ–¹æ³•å¿…é¡»ä¸åŸºç±»æ–¹æ³•å…·æœ‰ç›¸åŒçš„è¿”å›ç±»å‹ã€åç§°ã€å‚æ•°åˆ—è¡¨

åœ¨åŸºç±»ä¸­ï¼Œä½¿ç”¨ `virtual` å…³é”®å­—å£°æ˜å¯ä»¥è¢«é‡å†™çš„æ–¹æ³•ï¼š

```csharp
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Some sound");
    }
}
```

åœ¨æ´¾ç”Ÿç±»ä¸­ï¼Œä½¿ç”¨ `override` å…³é”®å­—é‡å†™åŸºç±»çš„è™šæ–¹æ³•ï¼š

```csharp
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}
```

æŠ½è±¡æ–¹æ³•å¿…é¡»è¢«æ´¾ç”Ÿç±»å®ç°ï¼š

```csharp
public abstract class Shape
{
    public abstract double CalculateArea();

    public virtual void Display()
    {
        Console.WriteLine("This is a shape");
    }
}

public class Circle : Shape
{
    private double radius;

    public override double CalculateArea()
    {
        return Math.PI * radius * radius;
    }
}
```

ä½¿ç”¨ `sealed` å…³é”®å­—é˜²æ­¢è¿›ä¸€æ­¥é‡å†™ï¼š

```csharp
public class Dog : Animal
{
    public sealed override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}
```

### 4ã€æ¥å£ä¸æŠ½è±¡ç±» ğŸ“

æ¥å£å’ŒæŠ½è±¡ç±»æ˜¯è®¾è®¡çµæ´»ä¸”å¯ç»´æŠ¤çš„ `C#` ä»£ç çš„é‡è¦å·¥å…·ã€‚

#### æ¥å£

`C#`ä¸æ”¯æŒç±»çš„å¤šé‡ç»§æ‰¿ã€‚ä½†æ˜¯ï¼Œä¸€ä¸ªç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£ã€‚

æ¥å£åªåŒ…å«æ–¹æ³•å£°æ˜ï¼Œä¸åŒ…å«å®ç°ã€‚

:::tip

æ¥å£ï¼šå®šä¹‰è¡Œä¸º

:::

#### æŠ½è±¡ç±»

æŠ½è±¡ç±»å¯ä»¥åŒ…å«å¸¦å®ç°å’Œä¸å¸¦å®ç°çš„æ–¹æ³•ã€‚

å®ƒä»¬ä¸èƒ½ç›´æ¥å®ä¾‹åŒ–ã€‚

ä¸€ä¸ªç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£ï¼Œä½†åªèƒ½ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»ã€‚

:::tip

æŠ½è±¡ç±»ï¼šå…±äº«åŸºç¡€å®ç°

:::

```csharp
// Interface definition
public interface IGameCharacter
{
    string Name { get; set; }

    void Attack();
    void Defend();

    void DisplayInfo()
    {
        Console.WriteLine($"Character Name: {Name}");
    }
}

// Abstract class definition
public abstract class BaseCharacter
{
    public string Name { get; set; }
    public int Health { get; set; }

    public BaseCharacter(string name)
    {
        Name = name;
        Health = 100;
    }

    // Abstract method (must be implemented by subclasses)
    public abstract void SpecialAbility();

    // Concrete method
    public virtual void TakeDamage(int amount)
    {
        Health -= amount;
        Console.WriteLine($"{Name} took {amount} damage");
    }
}

// Concrete class implementing the interface
public class Warrior : BaseCharacter, IGameCharacter
{
    public string Weapon { get; set; }

    public Warrior(string name, string weapon) : base(name)
    {
        Weapon = weapon;
    }

    // Interface method implementation
    public void Attack()
    {
        Console.WriteLine($"{Name} attacks with {Weapon}!");
    }

    public void Defend()
    {
        Console.WriteLine($"{Name} raises a shield to defend!");
    }

    // Abstract method implementation
    public override void SpecialAbility()
    {
        Console.WriteLine($"{Name} unleashes a berserker slash!");
    }
}

public class Mage : BaseCharacter, IGameCharacter
{
    public int ManaPoints { get; set; }

    public Mage(string name) : base(name)
    {
        ManaPoints = 100;
    }

    // Interface method implementation
    public void Attack()
    {
        Console.WriteLine($"{Name} casts a magical attack!");
        ManaPoints -= 10;
    }

    public void Defend()
    {
        Console.WriteLine($"{Name} uses a magical barrier!");
    }

    // Abstract method implementation
    public override void SpecialAbility()
    {
        Console.WriteLine($"{Name} unleashes a wide-area spell!");
    }
}

// Multiple interface implementation
public interface IDamageable
{
    void ReceiveDamage(int damage);
}

public interface IHealable
{
    void Heal(int amount);
}

public class ComplexCharacter : IGameCharacter, IDamageable, IHealable
{
    public string Name { get; set; }
    public int Health { get; set; }

    public void Attack() { }
    public void Defend() { }

    public void ReceiveDamage(int damage)
    {
        Health -= damage;
    }

    public void Heal(int amount)
    {
        Health += amount;
    }
}

public class Program
{
    public static void Main()
    {
        IGameCharacter warrior = new Warrior("Altaire", "Great Sword");
        IGameCharacter mage = new Mage("Michael");

        // Interface method calls
        warrior.Attack();
        mage.Attack();

        // Abstract class method
        BaseCharacter baseWarrior = new Warrior("Hero", "Long Sword");
        baseWarrior.TakeDamage(20);
        baseWarrior.SpecialAbility();

        // Interface default implementation
        warrior.DisplayInfo();
    }
}

// Generic interface example
public interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
    void Remove(T item);
}

public class CharacterRepository : IRepository<Warrior>
{
    public void Add(Warrior item) { }
    public Warrior GetById(int id) { return null; }
    public void Remove(Warrior item) { }
}
```

### 5ã€ç±»ä¸ç±»ä¹‹é—´çš„å…³ç³» ğŸ“

ä»å…³ç³»å¼ºåº¦ç”±å¼±åˆ°å¼ºæ’åºä¸ºï¼šå…³è” < èšåˆ < ç»„åˆ

#### ç»„åˆ

ç»„åˆæ˜¯ä¸€ç§å¼ºä¾èµ–çš„"æ•´ä½“-éƒ¨åˆ†"å…³ç³»ï¼Œéƒ¨åˆ†ä¸èƒ½è„±ç¦»æ•´ä½“è€Œå­˜åœ¨ã€‚

```csharp
public class Weapon
{
    public string Name { get; set; }
    public int Damage { get; set; }

    public void Attack()
    {
        Console.WriteLine($"{Name} attacks, dealing {Damage} damage");
    }
}

public class Armor
{
    public string Name { get; set; }
    public int Defense { get; set; }

    public void Protect()
    {
        Console.WriteLine($"{Name} provides {Defense} defense");
    }
}

public class GameCharacter
{
    // Composition: The character fully owns the weapon and armor
    private Weapon _weapon;
    private Armor _armor;

    public GameCharacter(string weaponName, string armorName)
    {
        _weapon = new Weapon { Name = weaponName, Damage = 50 };
        _armor = new Armor { Name = armorName, Defense = 30 };
    }

    public void Battle()
    {
        _weapon.Attack();
        _armor.Protect();
        Console.WriteLine("In battle...");
    }
}
```

#### èšåˆ

èšåˆè¡¨ç¤º"æ•´ä½“-éƒ¨åˆ†"çš„å…³ç³»ï¼Œä½†éƒ¨åˆ†å¯ä»¥ç‹¬ç«‹å­˜åœ¨ã€‚

```csharp
public interface IWeapon
{
    string Name { get; }
    int Damage { get; }
}

public class Sword : IWeapon
{
    public string Name { get; private set; }
    public int Damage { get; private set; }

    public Sword(string name, int damage)
    {
        Name = name;
        Damage = damage;
    }
}

public class Hero
{
    public string Name { get; private set; }
    public int Health { get; private set; }

    // Aggregation: Can change weapons
    private IWeapon _weapon;

    public Hero(string name)
    {
        Name = name;
        Health = 100;
    }

    // Equip weapon (aggregation relationship)
    public void EquipWeapon(IWeapon weapon)
    {
        _weapon = weapon;
        Console.WriteLine($"{Name} equipped {weapon.Name}");
    }

    public void Attack(Hero target)
    {
        if (_weapon != null)
        {
            int damage = _weapon.Damage;
            target.TakeDamage(damage);
            Console.WriteLine($"{Name} attacks {target.Name} with {_weapon.Name}");
        }
        else
        {
            Console.WriteLine($"{Name} has no weapon and cannot attack");
        }
    }

    public void TakeDamage(int damage)
    {
        Health -= damage;
        Console.WriteLine($"{Name} takes {damage} damage, remaining health {Health}");
    }
}

public class Program
{
    public static void Main()
    {
        Hero hero = new Hero("Hero");
        Hero enemy = new Hero("Goblin");

        IWeapon sword = new Sword("Hero's Sword", 20);
        IWeapon axe = new Sword("Giant Axe", 25);

        hero.EquipWeapon(sword);
        enemy.EquipWeapon(axe);

        hero.Attack(enemy);
        enemy.Attack(hero);
    }
}
```

#### å…³è”

å…³è”æ˜¯å¯¹è±¡ä¹‹é—´æœ€æ™®é€šçš„å¼•ç”¨å…³ç³»ï¼Œå¯¹è±¡ä¹‹é—´ç›¸äº’ç‹¬ç«‹ã€‚

```csharp
public class Player
{
    public string Name { get; set; }

    // Association: A player can have multiple characters
    public List<Character> Characters { get; set; }

    // Association: A player can join multiple guilds
    public List<Guild> Guilds { get; set; }

    public Player(string name)
    {
        Name = name;
        Characters = new List<Character>();
        Guilds = new List<Guild>();
    }

    public void AddCharacter(Character character)
    {
        Characters.Add(character);
    }

    public void JoinGuild(Guild guild)
    {
        Guilds.Add(guild);
        guild.AddMember(this);
    }
}

public class Character
{
    public string Name { get; set; }
    public int Level { get; set; }

    // Association: A character belongs to a specific player
    public Player Owner { get; set; }

    // Association: A character can equip items
    public List<Item> Equipment { get; set; }

    public Character(string name, Player owner)
    {
        Name = name;
        Owner = owner;
        Equipment = new List<Item>();
    }

    public void EquipItem(Item item)
    {
        Equipment.Add(item);
    }
}

public class Item
{
    public string Name { get; set; }
    public int Attack { get; set; }
    public int Defense { get; set; }

    // Association: An item can be owned by multiple characters
    public List<Character> Owners { get; set; }

    public Item(string name, int attack, int defense)
    {
        Name = name;
        Attack = attack;
        Defense = defense;
        Owners = new List<Character>();
    }
}

public class Guild
{
    public string Name { get; set; }

    // Association: A guild has multiple members
    public List<Player> Members { get; set; }

    public Guild(string name)
    {
        Name = name;
        Members = new List<Player>();
    }

    public void AddMember(Player player)
    {
        Members.Add(player);
    }
}

public class Program
{
    public static void Main()
    {
        Player player = new Player("Hero");
        Character warrior = new Character("Warrior", player);
        Character mage = new Character("Mage", player);

        player.AddCharacter(warrior);
        player.AddCharacter(mage);

        Item sword = new Item("Flame Dragon Sword", 50, 10);
        Item shield = new Item("Iron Shield", 5, 30);

        warrior.EquipItem(sword);
        warrior.EquipItem(shield);

        Guild heroGuild = new Guild("Hero League");

        player.JoinGuild(heroGuild);

        // Display associations
        Console.WriteLine($"Player {player.Name} has {player.Characters.Count} characters");
        Console.WriteLine($"Character {warrior.Name} has {warrior.Equipment.Count} pieces of equipment");
        Console.WriteLine($"Guild {heroGuild.Name} has {heroGuild.Members.Count} members");
    }
}
```

### 6ã€ç±»çš„é«˜çº§ç‰¹æ€§ ğŸ“

#### é™æ€æˆå‘˜

ä»¥ä¸‹éƒ½éœ€è¦ä½¿ç”¨ `static` å…³é”®å­—å£°æ˜ã€‚

<b>é™æ€å­—æ®µ</b>

ä¸éœ€è¦åˆ›å»ºç±»çš„å®ä¾‹å³å¯ä½¿ç”¨ï¼Œé€šè¿‡ç±»åç›´æ¥è®¿é—®`ClassName.StaticFieldName`ã€‚

- å­˜å‚¨åœ¨æ•°æ®æ®µä¸­ï¼Œåœ¨ç¨‹åºå¯åŠ¨æ—¶å°±åˆ†é…å†…å­˜
- è¢«ç±»çš„æ‰€æœ‰å®ä¾‹å…±äº«ï¼Œæ‰€æœ‰å®ä¾‹è®¿é—®åŒä¸€å†…å­˜ä½ç½®
- ç”Ÿå‘½å‘¨æœŸä¸åº”ç”¨ç¨‹åºç›¸åŒï¼Œä»ç¨‹åºå¯åŠ¨åˆ°ç¨‹åºç»“æŸ

<b>é™æ€æ–¹æ³•</b>

é™æ€æ–¹æ³•æ˜¯å±äºç±»æœ¬èº«è€Œä¸æ˜¯ç±»çš„å®ä¾‹çš„æ–¹æ³•ã€‚

- ä¸éœ€è¦åˆ›å»ºç±»çš„å®ä¾‹å°±èƒ½è°ƒç”¨
- åªèƒ½ç›´æ¥è®¿é—®ç±»çš„å…¶ä»–é™æ€æˆå‘˜
- ä¸èƒ½ä½¿ç”¨ `this` å…³é”®å­—

<b>é™æ€æ„é€ å‡½æ•°</b>

é™æ€æ„é€ å‡½æ•°ç”¨äºåˆå§‹åŒ–ç±»çš„é™æ€æˆå‘˜æˆ–æ‰§è¡Œåªåº”åœ¨ç±»ä¸­å‘ç”Ÿä¸€æ¬¡çš„æ“ä½œï¼Œè€Œä¸æ˜¯é’ˆå¯¹æ¯ä¸ªå•ç‹¬çš„å¯¹è±¡ã€‚

- æ¯ä¸ªç±»åªèƒ½æœ‰ä¸€ä¸ªé™æ€æ„é€ å‡½æ•°
- ä¸èƒ½æœ‰å‚æ•°
- ä¸èƒ½æœ‰è®¿é—®ä¿®é¥°ç¬¦
- è‡ªåŠ¨è°ƒç”¨ï¼Œä¸èƒ½æ‰‹åŠ¨è°ƒç”¨
- åœ¨ç±»ç¬¬ä¸€æ¬¡è¢«ä½¿ç”¨å‰æ‰§è¡Œ

<b>é™æ€ç±»</b>

é™æ€ç±»æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»ï¼ŒåªåŒ…å«é™æ€æˆå‘˜ï¼Œä¸èƒ½è¢«å®ä¾‹åŒ–ã€‚

- éšå¼å¯†å°ï¼ˆsealedï¼‰ï¼Œè¿™æ„å‘³ç€å®ƒä»¬ä¸èƒ½è¢«ç»§æ‰¿
- ä¸èƒ½åŒ…å«å®ä¾‹æ„é€ å‡½æ•°
- ä¸èƒ½è¢«ç»§æ‰¿

<b>é™æ€å±æ€§</b>

é™æ€å±æ€§æ˜¯å±äºç±»è€Œä¸æ˜¯å®ä¾‹çš„å±æ€§ã€‚

- é€šè¿‡ç±»åç›´æ¥è®¿é—®çš„ï¼Œä¸éœ€è¦åˆ›å»ºç±»çš„å®ä¾‹
- æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´åªå­˜åœ¨ä¸€ä¸ªå…±äº«çš„å‰¯æœ¬ï¼Œæ‰€æœ‰å¯¹è±¡å…±äº«è¿™ä¸ªå±æ€§
- å¯ä»¥æ˜¯åªè¯»ã€åªå†™æˆ–è¯»å†™

```csharp
public class GameSettings
{
    // Static fields: Global game settings
    public static int MaxLevel = 100;
    public static int StartingGold = 1000;

    // Static read-only field: Unmodifiable constant
    public static readonly string GameVersion = "1.0.0";
}

public class Player
{
    // Instance fields
    public string Name { get; }
    public int Gold { get; }

    // Static field: Record total number of players
    private static int _totalPlayers;

    // Static property: Get current total number of players
    public static int TotalPlayers => _totalPlayers;

    public Player(string name)
    {
        Name = name;
        Gold = GameSettings.StartingGold;

        // Increment total players count for each new player created
        _totalPlayers++;
    }

    // Static method: Reset player count
    public static void ResetPlayerCount()
    {
        _totalPlayers = 0;
    }
}

public class MonsterManager
{
    // Static field: Global monster kill counter
    private static int _totalMonstersKilled;

    // Static method: Record monster kill
    public static void RecordMonsterKill()
    {
        _totalMonstersKilled++;
    }

    // Static method: Get total kills
    public static int GetTotalMonstersKilled()
    {
        return _totalMonstersKilled;
    }
}

public class Program
{
    public static void Main()
    {
        // Using static fields and methods
        Console.WriteLine($"Game Version: {GameSettings.GameVersion}");
        Console.WriteLine($"Max Level: {GameSettings.MaxLevel}");

        // Create players
        Player player = new Player("Hero");
        if (player == null) throw new ArgumentNullException(nameof(player));

        // Using static property
        Console.WriteLine($"Current Total Players: {Player.TotalPlayers}");

        // Simulate battles
        MonsterManager.RecordMonsterKill();
        MonsterManager.RecordMonsterKill();
        MonsterManager.RecordMonsterKill();

        Console.WriteLine($"Total Monsters Killed: {MonsterManager.GetTotalMonstersKilled()}");

        // Demonstrate the characteristics of static fields
        Console.WriteLine($"{player.Name}'s Initial Gold: {player.Gold}");
    }
}
```

#### ç‰¹æ€§

ç‰¹æ€§ç”¨äºå°†å…ƒæ•°æ®æ·»åŠ åˆ°ç¨‹åºå…ƒç´ ï¼ˆä¾‹å¦‚ç±»ã€æ–¹æ³•å’Œå±æ€§ï¼‰ï¼Œè¿™å¯ä»¥åœ¨è¿è¡Œæ—¶æ”¹å˜å®ƒä»¬çš„è¡Œä¸ºã€‚

<b>é¢„å®šä¹‰ç‰¹æ€§</b>

- `Obsolete`â€”â€” æ ‡è®°å·²è¿‡æ—¶çš„ä»£ç 

- `Serializable` â€”â€” æ ‡è®°å¯åºåˆ—åŒ–çš„ç±»
- `Conditional` â€”â€” ç”¨äºæ¡ä»¶ç¼–è¯‘
- `AttributeUsage` â€”â€” æè¿°ç‰¹æ€§çš„ä½¿ç”¨æ–¹å¼

<b>è‡ªå®šä¹‰ç‰¹æ€§</b>

- å¿…é¡»ç»§æ‰¿è‡ª `Attribute` ç±»

- ç±»åé€šå¸¸ä»¥ `Attribute` ç»“å°¾
- å¯ä»¥åŒ…å«æ„é€ å‡½æ•°å’Œå±æ€§

```csharp
using System.Reflection;

// Custom Attribute: Character Description
[AttributeUsage(AttributeTargets.Class)]
public class CharacterDescriptionAttribute(string description) : Attribute
{
    public string Description { get; } = description;
}

// Attribute Validation
[AttributeUsage(AttributeTargets.Property)]
public class ValidRangeAttribute(int min, int max) : Attribute
{
    public int Min { get; } = min;
    public int Max { get; } = max;

    public bool IsValid(int value)
    {
        return value >= Min && value <= Max;
    }
}

// Character class using attributes
[CharacterDescription("Brave Adventurer")]
public class GameCharacter(string name, int level, int health)
{
    public string Name { get; set; } = name;

    [ValidRange(1, 100)]
    public int Level { get; set; } = level;

    [ValidRange(10, 500)]
    public int Health { get; set; } = health;

    // Method to validate properties using attributes
    public bool Validate()
    {
        var properties = GetType().GetProperties();

        foreach (var prop in properties)
        {
            if (prop.GetCustomAttributes(typeof(ValidRangeAttribute), false)
                    .FirstOrDefault() is ValidRangeAttribute validRangeAttr)
            {
                var value = (int)prop.GetValue(this);
                if (!validRangeAttr.IsValid(value))
                {
                    Console.WriteLine($"Property {prop.Name} validation failed: value must be between {validRangeAttr.Min} and {validRangeAttr.Max}");
                    return false;
                }
            }
        }
        return true;
    }

    // Get the description of the class
    public string GetDescription()
    {
        var attribute = GetType().GetCustomAttribute<CharacterDescriptionAttribute>();
        return attribute?.Description ?? "No description";
    }
}

public class Program
{
    public static void Main()
    {
        // Create character
        GameCharacter hero = new GameCharacter("Hero", 50, 200);

        // Validate character properties
        if (hero.Validate())
        {
            Console.WriteLine("Character property validation passed");
        }

        // Get character description
        Console.WriteLine($"Character description: {hero.GetDescription()}");

        // Test invalid properties
        GameCharacter invalidHero = new GameCharacter("Invalid Character", 150, 600);
        if (!invalidHero.Validate())
        {
            Console.WriteLine("Character property validation failed");
        }
    }
}
```

#### åå°„

åå°„å…è®¸åœ¨è¿è¡Œæ—¶æ£€æŸ¥ã€ä¿®æ”¹å’Œåˆ›å»ºç±»å‹ã€æ–¹æ³•å’Œå±æ€§ã€‚

```csharp
using System.Reflection;

// Base class for characters
public abstract class Character
{
    public string Name { get; set; }
    public int Health { get; set; }

    public abstract void Attack();
}

// Warrior class
public class Warrior : Character
{
    public int Strength { get; set; }

    public Warrior(string name, int health, int strength)
    {
        Name = name;
        Health = health;
        Strength = strength;
    }

    public override void Attack()
    {
        Console.WriteLine($"{Name} attacks with a sword!");
    }

    public void SpecialSkill()
    {
        Console.WriteLine($"{Name} uses Fury Slash!");
    }
}

// Mage class
public class Mage : Character
{
    public int Mana { get; set; }

    public Mage(string name, int health, int mana)
    {
        Name = name;
        Health = health;
        Mana = mana;
    }

    public override void Attack()
    {
        Console.WriteLine($"{Name} casts a magic attack!");
    }

    public void CastSpell()
    {
        Console.WriteLine($"{Name} casts a high-level spell!");
    }
}

// Reflection helper class
public abstract class ReflectionHelper
{
    // Create an object
    public static object? CreateInstance(string typeName)
    {
        Type? type = Type.GetType(typeName);
        return Activator.CreateInstance(type, "Default Character", 100, 50);
    }

    // Get all public methods
    public static void GetMethods(object? obj)
    {
        Type? type = obj?.GetType();
        Console.WriteLine($"All public methods of type {type?.Name}:");

        MethodInfo[]? methods = type?.GetMethods(
            BindingFlags.Public |
            BindingFlags.Instance |
            BindingFlags.DeclaredOnly
        );

        if (methods != null)
            foreach (var method in methods)
            {
                Console.WriteLine(method.Name);
            }
    }

    // Invoke a method
    public static void InvokeMethod(object? obj, string methodName)
    {
        Type? type = obj?.GetType();
        MethodInfo? method = type?.GetMethod(methodName);

        if (method != null)
        {
            method.Invoke(obj, null);
        }
        else
        {
            Console.WriteLine($"Method {methodName} not found");
        }
    }

    // Display property values
    public static void DisplayProperties(object? obj)
    {
        Type? type = obj?.GetType();
        PropertyInfo[]? properties = type?.GetProperties();

        Console.WriteLine($"Properties of type {type?.Name}:");
        if (properties != null)
            foreach (var prop in properties)
            {
                object? value = prop.GetValue(obj);
                Console.WriteLine($"{prop.Name}: {value}");
            }
    }
}

public class Program
{
    public static void Main()
    {
        // Create an object using reflection
        Warrior warrior = (Warrior)ReflectionHelper.CreateInstance("Warrior")!;

        // Display object properties
        ReflectionHelper.DisplayProperties(warrior);

        // Get object methods
        ReflectionHelper.GetMethods(warrior);

        // Invoke specific methods
        ReflectionHelper.InvokeMethod(warrior, "Attack");
        ReflectionHelper.InvokeMethod(warrior, "SpecialSkill");

        // Dynamically create and use an object
        object? dynamicMage = ReflectionHelper.CreateInstance("Mage");
        ReflectionHelper.InvokeMethod(dynamicMage, "Attack");
    }
}
```

## ä¸‰ã€å¼‚å¸¸å¤„ç† ğŸš¨

å¼‚å¸¸å¤„ç†æ˜¯å…è®¸æ£€æµ‹å’Œå¤„ç†ç¨‹åºæ‰§è¡ŒæœŸé—´å‘ç”Ÿçš„é”™è¯¯ï¼Œé˜²æ­¢å´©æºƒå’Œä¸å¯é¢„è§çš„ç»“æœã€‚

### 1ã€åŸºç¡€å¼‚å¸¸å¤„ç† ğŸ“

åœ¨ `C#` ä¸­ï¼Œä¸»è¦çš„é”™è¯¯å¤„ç†æœºåˆ¶åŸºäº `try`ã€`catch`ã€`finally` å’Œ `throw` ç»“æ„çš„ä½¿ç”¨ã€‚

`try-catch` å—ç”¨äºå¤„ç†å¼‚å¸¸ã€‚å¯èƒ½å¼•å‘å¼‚å¸¸çš„ä»£ç æ”¾åœ¨ `try` å—å†…ï¼Œç›¸åº”çš„å¼‚å¸¸å¤„ç†ä»£ç æ”¾åœ¨ `catch` å—å†…ã€‚

`try-catch` ç»“æ„ä¸­ `finally` å—çš„ä½œç”¨æ˜¯ç¡®ä¿æ— è®ºå‰é¢çš„ `try` æˆ– `catch` å—ä¸­æ˜¯å¦æŠ›å‡ºå¼‚å¸¸ï¼Œå…¶å†…éƒ¨çš„ä»£ç éƒ½ä¼šè¢«æ‰§è¡Œã€‚è¿™å¯¹äºæ¸…ç†æ“ä½œç‰¹åˆ«æœ‰ç”¨ï¼Œä¾‹å¦‚å…³é—­æ–‡ä»¶æˆ–æ•°æ®åº“è¿æ¥ã€‚

åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œ`finally` å—å°†è¢«æ‰§è¡Œã€‚ä½†æ˜¯ï¼Œåœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œä¾‹å¦‚ç¨‹åºç»ˆæ­¢æˆ–ç¾éš¾æ€§å¼‚å¸¸ï¼ˆä¾‹å¦‚ `StackOverflowException` æˆ–è¿›ç¨‹ç»ˆæ­¢ï¼‰ï¼Œ`finally` å—å¯èƒ½æ— æ³•æ‰§è¡Œï¼Œå› ä¸ºè¿™äº›ä¸¥é‡é”™è¯¯å¯èƒ½ä¼šä¸­æ–­ç¨‹åºæ‰§è¡Œçš„æ­£å¸¸æµç¨‹ï¼Œå¹¶ä¸”åº”ç”¨ç¨‹åºå°†åœæ­¢ï¼Œä»è€Œå¯¼è‡´ `finally` å—æ²¡æœ‰æœºä¼šè¿è¡Œã€‚

**â€‹`finally`â€‹** **å¯èƒ½æ— æ³•æ‰§è¡Œçš„åœºæ™¯ï¼š**

1. å¦‚æœåº”ç”¨ç¨‹åºå´©æºƒæˆ–è¢«å¼ºåˆ¶ç»ˆæ­¢
2. å¦‚æœ `try` æˆ– `catch` å—ä¸­å­˜åœ¨æ— é™å¾ªç¯
3. å¦‚æœè°ƒç”¨äº† `Environment.FailFast()` æˆ– `Process.Kill()`
4. åœ¨æç«¯çš„ç³»ç»Ÿçº§æ•…éšœæˆ–ç¡¬ä»¶é—®é¢˜ä¸­

```csharp
try
{
    // Code that may throw an exception
    int result = 10 / int.Parse("0");
}
catch (DivideByZeroException ex)
{
    // Handling specific exception
    Console.WriteLine($"Error: {ex.Message}");
}
catch (Exception ex)
{
    // Handling any other exception
    Console.WriteLine($"An unexpected error occurred: {ex.Message}");
}
finally
{
    // Code that will be executed regardless of whether an exception occurred
    Console.WriteLine("This code always executes, even if an exception occurred.");
}
```

æ‚¨å¯ä»¥ä½¿ç”¨ `throw` å…³é”®å­—æ‰‹åŠ¨å¼•å‘å¼‚å¸¸ã€‚å½“æ‚¨æƒ³è¦æŒ‡ç¤ºå‘ç”Ÿäº†æŸç§æƒ…å†µæˆ–é”™è¯¯æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚

```csharp
public class Calculator
{
    public int Divide(int dividend, int divisor)
    {
        if (divisor == 0)
        {
            throw new DivideByZeroException("Cannot divide by zero.");
        }
        return dividend / divisor;
    }
}
```

### 2ã€å¸¸è§å¼‚å¸¸ç±»å‹ ğŸ”

`C#` å…·æœ‰å¤šç§å¼‚å¸¸ç±»å‹ï¼Œå¯ä»¥æ»¡è¶³ä¸åŒçš„å¼‚å¸¸åœºæ™¯ã€‚

- `ArgumentNullException`ï¼šå½“ä¼ é€’ç»™æ–¹æ³•çš„å‚æ•°ä¸º null æ—¶æŠ›å‡ºæ­¤å¼‚å¸¸ï¼Œå½“éœ€è¦éç©ºå€¼æ—¶
- `ArgumentOutOfRangeException`ï¼šå½“å‚æ•°çš„å€¼è¶…å‡ºå…è®¸èŒƒå›´æ—¶ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µ
- `DivideByZeroException`ï¼šå½“å°è¯•é™¤ä»¥é›¶æ—¶æŠ›å‡ºæ­¤å¼‚å¸¸
- `InvalidOperationException`ï¼šå½“å¯¹è±¡çš„çŠ¶æ€ä¸å…è®¸ç‰¹å®šæ“ä½œæ—¶ä¼šå‡ºç°è¿™ç§æƒ…å†µ
- `FileNotFoundException`ï¼šå½“å°è¯•è®¿é—®çš„æ–‡ä»¶ä¸å­˜åœ¨æ—¶ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µ
- `StackOverflowException`ï¼šå½“ç”±äºè¿‡å¤šé€’å½’æˆ–å…¶ä»–åŸå› å¯¼è‡´å †æ ˆæº¢å‡ºæ—¶æŠ›å‡ºæ­¤å¼‚å¸¸
- `NullReferenceException`ï¼šå½“æ‚¨å°è¯•è®¿é—®ç©ºå¼•ç”¨å¯¹è±¡çš„æˆå‘˜æ—¶ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µ

### 3ã€è‡ªå®šä¹‰å¼‚å¸¸ ğŸ“

åœ¨ `C#` ä¸­ï¼Œå¼‚å¸¸è¢«å®ç°ä¸ºä» Exception åŸºç±»ç»§æ‰¿çš„å¯¹è±¡ã€‚è¿™å…è®¸ä¼ é€’æœ‰å…³å¼‚å¸¸çš„é™„åŠ ä¿¡æ¯å¹¶åˆ›å»ºè‡ªå®šä¹‰å¼‚å¸¸ç±»å‹ã€‚è¦åˆ›å»ºæ‚¨è‡ªå·±çš„å¼‚å¸¸ç±»ï¼Œåªéœ€ä» Exception ç±»æˆ–å…¶å­ç±»ä¹‹ä¸€ç»§æ‰¿å®ƒå³å¯ã€‚

æ‚¨å¯ä»¥é€šè¿‡ä» Exception ç±»æ´¾ç”Ÿæ¥åˆ›å»ºè‡ªå·±çš„è‡ªå®šä¹‰å¼‚å¸¸ç±»ã€‚è¿™å…è®¸æ‚¨ä¸ºæ‚¨çš„åº”ç”¨ç¨‹åºå®šä¹‰ç‰¹å®šçš„å¼‚å¸¸ç±»å‹ã€‚

```csharp
public class CustomException : Exception
{
    public CustomException(string message) : base(message)
    {

    }
}
```

```csharp
// Custom exception class
public class BusinessException : Exception
{
    public string ErrorCode { get; }

    public BusinessException(string message) : base(message)
    {
    }

    public BusinessException(string message, string errorCode)
        : base(message)
    {
        ErrorCode = errorCode;
    }

    public BusinessException(string message, Exception innerException)
        : base(message, innerException)
    {
    }
}

// Using the custom exception
public class BusinessLogic
{
    public void ProcessOrder(Order order)
    {
        if (order == null)
        {
            throw new BusinessException("Order cannot be null", "ORDER001");
        }

        if (order.Amount <= 0)
        {
            throw new BusinessException("Order amount must be greater than 0", "ORDER002");
        }
    }
}
```

### 4ã€å¼‚å¸¸è¿‡æ»¤å™¨ ğŸ”€

å¼‚å¸¸è¿‡æ»¤å™¨å…è®¸æ‚¨æ ¹æ®ç‰¹å®šæ¡ä»¶æ•è·å¼‚å¸¸ã€‚

```csharp
try
{
    // Code that may throw an exception
    int result = 10 / int.Parse("0");
}
catch (DivideByZeroException ex) when (ex.Message == "Attempted to divide by zero.")
{
    // Handling specific exception with a filter
    Console.WriteLine($"Error: {ex.Message}");
}
```

## å››ã€é›†åˆä¸æ³›å‹ ğŸ“ˆ

### 1ã€å¸¸ç”¨é›†åˆ ğŸ”—

`C#` ä¸­çš„æ•°ç»„å’Œé›†åˆç”¨äºå­˜å‚¨æ•°æ®ï¼Œå¹¶å…è®¸ä»¥æ˜“äºè®¿é—®å’Œæ“ä½œçš„æ–¹å¼ç»„ç»‡æ•°æ®ï¼š

- æ•°ç»„æ˜¯é™æ€é›†åˆï¼Œèƒ½å¤Ÿå­˜å‚¨å›ºå®šæ•°é‡çš„å•ä¸€ç±»å‹å…ƒç´ ã€‚
- é›†åˆæ˜¯åŠ¨æ€çš„ï¼Œå¯ä»¥å­˜å‚¨å¯å˜æ•°é‡çš„å…ƒç´ ï¼›å®ƒä»¬æœ‰ä¸åŒçš„è¡¨ç°ç±»å‹ï¼Œä¾‹å¦‚åˆ—è¡¨ã€å­—å…¸ã€å †æ ˆã€é˜Ÿåˆ—ç­‰ã€‚

.NET æä¾›äº†å‡ ç§ä¸»è¦çš„é›†åˆç±»å‹ï¼š

- `List<T>`ï¼šå…ƒç´ çš„åŠ¨æ€æ•°ç»„ã€‚å®ƒç»´æŒé¡ºåºå¹¶å…è®¸é‡å¤å…ƒç´ ã€‚

- `Dictionary<TKey, TValue>`ï¼šé”®å€¼å¯¹çš„é›†åˆã€‚å®ƒæ²¡æœ‰ä¸€ä¸ªå®šä¹‰çš„é¡ºåºï¼Œå¹¶ä¸”é”®å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚

- `HashSet<T>`ï¼šä¸€ç»„å”¯ä¸€å…ƒç´ ã€‚å®ƒä¸ç»´æŠ¤ä»»ä½•ç‰¹å®šçš„é¡ºåºã€‚
- `Queue<T>`ï¼šæ”¯æŒå…ˆè¿›å…ˆå‡º(FIFO) æ“ä½œçš„é›†åˆã€‚

- `Stack<T>`ï¼šæ”¯æŒåè¿›å…ˆå‡º (LIFO) æ“ä½œçš„é›†åˆã€‚

#### Array

`C#`ä¸­çš„æ•°ç»„æ˜¯ç›¸åŒæ•°æ®ç±»å‹å…ƒç´ çš„å›ºå®šå¤§å°é›†åˆã€‚

```csharp
// Declaration and Initialization
int[] numbers = new int[5] { 1, 2, 3, 4, 5 };

// Accessing Elements
int firstElement = numbers[0]; // Accessing the first element (index 0)

// Iterating Through Arrays
foreach (int number in numbers)
{
    Console.WriteLine(number);
}

// Multidimensional Arrays
int[,] matrix = new int[3, 3]
{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

#### List

åˆ—è¡¨æä¾›åŠ¨æ€å¤§å°è°ƒæ•´å’Œå…¶ä»–åŠŸèƒ½ã€‚

```csharp
// Declaration and Initialization
List<string> names = new List<string>() { "Alice", "Bob", "Charlie" };

// Adding and Removing Elements
names.Add("David"); // Add an element
names.Remove("Bob"); // Remove an element by value
names.RemoveAt(0); // Remove an element by index

// Accessing Elements
string firstElement = names[0]; // Accessing the first element (index 0)

// Iterating Through Lists
foreach (string name in names)
{
    Console.WriteLine(name);
}
```

:::info

æ•°ç»„é€šå¸¸åœ¨ç´¢å¼•è®¿é—®å’Œå†…å­˜æ•ˆç‡æ–¹é¢æ›´å¿«ï¼Œå½“é¡¹ç›®æ•°é‡é¢„å…ˆå·²çŸ¥ä¸”ä¿æŒä¸å˜æ—¶æœ€ä¸ºç†æƒ³ã€‚`List<T>` æä¾›æ›´å¤šæ“ä½œæ–¹æ³•ï¼Œæ›´é€‚åˆå¤§å°ä¸ç¡®å®šçš„åŠ¨æ€é›†åˆã€‚

:::

#### Dictionary

`C#` ä¸­çš„å­—å…¸æ˜¯å­˜å‚¨é”®å€¼å¯¹çš„é›†åˆï¼Œå¯ä»¥æ ¹æ®å…³è”çš„é”®å¿«é€Ÿè®¿é—®å€¼ã€‚

```csharp
// Declaration and Initialization
Dictionary<string, int> ages = new Dictionary<string, int>()
{
    {"Alice", 25},
    {"Bob", 30},
    {"Charlie", 22}
};

// Adding and Accessing Elements
ages["David"] = 28; // Add a new key-value pair
int bobAge = ages["Bob"]; // Access the value using the key

// Iterating Through Dictionaries
foreach (var pair in ages)
{
    Console.WriteLine($"{pair.Key}: {pair.Value}");
}

// Checking for Key Existence
bool hasAlice = ages.ContainsKey("Alice"); // true
bool hasEve = ages.ContainsKey("Eve"); // false
```

#### HashSet

`C#` ä¸­çš„ `HashSet` æ˜¯å­˜å‚¨å”¯ä¸€å…ƒç´ çš„é›†åˆï¼Œæ²¡æœ‰ä»»ä½•ç‰¹å®šçš„é¡ºåºã€‚

```csharp
// Declaration and Initialization
HashSet<int> uniqueNumbers = new HashSet<int>() { 1, 2, 3, 4, 5 };

// Adding and Removing Elements
uniqueNumbers.Add(6); // Add a new element
uniqueNumbers.Remove(3); // Remove an element

// Checking for Element Existence
bool hasThree = uniqueNumbers.Contains(3); // false
bool hasFive = uniqueNumbers.Contains(5); // true

// Set Operations
HashSet<int> otherNumbers = new HashSet<int>() { 4, 5, 6, 7, 8 };

// Union
HashSet<int> unionSet = new HashSet<int>(uniqueNumbers);
unionSet.UnionWith(otherNumbers); // {1, 2, 3, 4, 5, 6, 7, 8}

// Intersection
HashSet<int> intersectionSet = new HashSet<int>(uniqueNumbers);
intersectionSet.IntersectWith(otherNumbers); // {4, 5}

// Difference
HashSet<int> differenceSet = new HashSet<int>(uniqueNumbers);
differenceSet.ExceptWith(otherNumbers); // {1, 2, 3}
```

:::tip

å½“éœ€è¦é˜²æ­¢é‡å¤æˆ–æ‰§è¡Œé¢‘ç¹çš„æŸ¥æ‰¾æ“ä½œæ—¶ï¼Œå®ƒæœ€ä¸ºç†æƒ³ã€‚

:::

#### Queue å’Œ Stack

```csharp
// Queue (First In First Out - FIFO)
Queue<string> queue = new Queue<string>();

// Enqueue
queue.Enqueue("First");
queue.Enqueue("Second");

// Dequeue
string item = queue.Dequeue();

// Peek at the front element without removing it
string peek = queue.Peek();

// Stack (Last In First Out - LIFO)
Stack<string> stack = new Stack<string>();

// Push onto the stack
stack.Push("First");
stack.Push("Second");

// Pop from the stack
string item = stack.Pop();

// Peek at the top element without removing it
string peek = stack.Peek();
```

### 2ã€æ³›å‹ç¼–ç¨‹ ğŸ”€

é«˜æ•ˆã€å¥å£®çš„ç¼–ç¨‹çš„æ ¸å¿ƒåœ¨äºç¼–å†™ç»å¾—èµ·æ—¶é—´è€ƒéªŒã€é€‚åº”ä¸åŒåœºæ™¯å¹¶æœ€å¤§é™åº¦å‡å°‘å†—ä½™çš„ä»£ç çš„èƒ½åŠ›ã€‚

æ³›å‹å…è®¸æ›´æŠ½è±¡å’Œé€šç”¨çš„ç¼–ç é£æ ¼ï¼Œè€Œä¸æ˜¯è‡´åŠ›äºç‰¹å®šçš„æ•°æ®ç±»å‹ï¼Œç¡®ä¿æ‚¨å¯ä»¥æ»¡è¶³å¹¿æ³›çš„éœ€æ±‚ï¼Œè€Œæ— éœ€æ‰¿æ‹…è¿‡å¤šçš„ä»£ç é‡å¤çš„è´Ÿæ‹…ã€‚

`C#` ä¸­çš„æ³›å‹å…è®¸åˆ›å»ºå¯æ“ä½œä¸åŒæ•°æ®ç±»å‹çš„ç±»ã€æ¥å£å’Œæ–¹æ³•ï¼Œè€Œä¸ä¼šæŸå¤±ç±»å‹å®‰å…¨æ€§å’Œæ€§èƒ½ã€‚å®ƒä»¬åœ¨åˆ›å»ºå¯å¤„ç†ä»»ä½•æ•°æ®ç±»å‹çš„å¤šåŠŸèƒ½ä¸”çµæ´»çš„é›†åˆã€æœåŠ¡å’Œå…¶ä»–ç»„ä»¶æ–¹é¢å‘æŒ¥ç€å…³é”®ä½œç”¨ã€‚

ä¸ä½¿ç”¨å¯¹è±¡ç±»å‹ç›¸æ¯”ï¼Œæ³›å‹å…·æœ‰ä»¥ä¸‹ä¼˜ç‚¹ï¼š

- ç±»å‹å®‰å…¨ï¼šæ³›å‹ç¡®ä¿æ‚¨ä½¿ç”¨æ­£ç¡®çš„æ•°æ®ç±»å‹ï¼Œä»è€Œæ¶ˆé™¤äº†è¿è¡Œæ—¶ç±»å‹é”™è¯¯çš„é£é™©ã€‚

- æ€§èƒ½ï¼šä½¿ç”¨æ³›å‹ï¼Œåœ¨å¤„ç†å€¼ç±»å‹æ—¶æ— éœ€è£…ç®±æˆ–æ‹†ç®±ï¼Œä»è€Œæé«˜è¿è¥æ•ˆç‡ã€‚
- ä»£ç å¯é‡ç”¨æ€§ï¼šæ³›å‹å…è®¸æ‚¨ç¼–å†™ä¸€æ®µå¯å¤„ç†ä¸åŒæ•°æ®ç±»å‹çš„ä»£ç ï¼Œå‡å°‘ä»£ç é‡å¤ã€‚
- æ¶ˆé™¤ç±»å‹è½¬æ¢ï¼šä½¿ç”¨æ³›å‹ï¼Œå¯ä»¥å‡å°‘æ˜¾å¼ç±»å‹è½¬æ¢ï¼Œä»è€Œä½¿ä»£ç æ›´å¹²å‡€ã€æ›´å…·å¯è¯»æ€§ã€‚

åœ¨ .NET ä¸­ï¼Œæ³›å‹ç±»å‹è¢«ç¼–è¯‘ä¸ºä¸­é—´è¯­è¨€ (IL) çš„å•ä¸ªæ¨¡æ¿ã€‚

å½“è¿è¡Œæ—¶éœ€è¦ç‰¹å®šç±»å‹å®ä¾‹æ—¶ï¼Œå³æ—¶ (JIT) ç¼–è¯‘å™¨ä¼šç”Ÿæˆä¸“ç”¨ä»£ç ã€‚

å¯¹äºå€¼ç±»å‹ï¼ˆä¾‹å¦‚ intã€doubleï¼‰ï¼Œå°†ä¸ºæ¯ç§ç±»å‹ç”Ÿæˆå•ç‹¬çš„ä»£ç ä»¥ç¡®ä¿ä¼˜åŒ–æ€§èƒ½ã€‚

ç„¶è€Œï¼Œå¯¹äºå¼•ç”¨ç±»å‹ï¼Œç›¸åŒçš„ä»£ç æ˜¯å…±äº«çš„ï¼Œä»è€Œä½¿è¿‡ç¨‹æ›´åŠ èŠ‚çœå†…å­˜ã€‚

æ³›å‹å¯ä»¥ä¸ `C#` ä¸­çš„å„ç§åŠŸèƒ½ç»“åˆä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š

- å§”æ‰˜ï¼šæ‚¨å¯ä»¥å®šä¹‰é€šç”¨å§”æ‰˜ï¼Œå®ƒå¯ä»¥æŒ‡å‘å„ç§ç±»å‹çš„æ–¹æ³•ã€‚
- äº‹ä»¶ï¼šäº‹ä»¶å¯ä»¥åŸºäºé€šç”¨å§”æ‰˜ã€‚

- å±æ€§ï¼šè™½ç„¶æ‚¨æ— æ³•åˆ›å»ºé€šç”¨å±æ€§ç±»ï¼Œä½†æ‚¨å¯ä»¥å°†å±æ€§åº”ç”¨äºé€šç”¨ç»“æ„ã€‚

#### æ³›å‹ç±»

æ³›å‹ç±»å‹æ‰©å±•æ–¹æ³•å…è®¸å¼€å‘äººå‘˜å‘ç°æœ‰ç±»å‹ï¼ˆå†…ç½®ç±»å‹å’Œç”¨æˆ·å®šä¹‰ç±»å‹ï¼‰æ·»åŠ æ–¹æ³•ï¼Œè€Œæ— éœ€ä¿®æ”¹å®ƒä»¬æˆ–åˆ›å»ºæ–°çš„æ´¾ç”Ÿç±»å‹ã€‚

```csharp
// Basic Generic Class
public class GenericContainer<T>
{
    private T _item;

    public GenericContainer(T item)
    {
        _item = item;
    }

    public T GetItem()
    {
        return _item;
    }

    public void SetItem(T item)
    {
        _item = item;
    }
}

// Multiple Type Parameters
public class KeyValuePair<TKey, TValue>
{
    public TKey Key { get; set; }
    public TValue Value { get; set; }

    public KeyValuePair(TKey key, TValue value)
    {
        Key = key;
        Value = value;
    }
}

// Usage Example
public class GenericExample
{
    public void UseGenericTypes()
    {
        var intContainer = new GenericContainer<int>(42);
        var stringContainer = new GenericContainer<string>("Hello");
        var pair = new KeyValuePair<int, string>(1, "One");
    }
}
```

#### æ³›å‹æ–¹æ³•

æ³›å‹æ–¹æ³•æ˜¯ `C#` ä¸­ä¸€ç§ç‰¹æ®Šçš„æ–¹æ³•ç±»å‹ï¼Œå…è®¸æ–¹æ³•çš„å‚æ•°ç±»å‹åœ¨ä½¿ç”¨æ—¶æ‰ç¡®å®šã€‚

```csharp
public class GenericMethods
{
    // Basic Generic Method
    public T GenericMethod<T>(T item)
    {
        Console.WriteLine($"Type: {typeof(T)}, Value: {item}");
        return item;
    }

    // Generic Method with Multiple Type Parameters
    public TResult Convert<TInput, TResult>(TInput input)
        where TResult : new()
    {
        TResult result = new TResult();
        // Conversion logic
        return result;
    }

    // Generic Method in a Non-Generic Class
    public static void Swap<T>(ref T first, ref T second)
    {
        T temp = first;
        first = second;
        second = temp;
    }
}
```

#### æ³›å‹çº¦æŸ

çº¦æŸå¯ä»¥åº”ç”¨äºæ³›å‹ï¼Œä»¥é™åˆ¶å¯ä»¥ç”¨ä½œå‚æ•°çš„ç±»å‹ã€‚

```csharp
// Class Constraint
public class ClassConstraint<T> where T : class
{
    public T Instance { get; set; }
}

// Value Type Constraint
public class ValueTypeConstraint<T> where T : struct
{
    public T Value { get; set; }
}

// Constructor Constraint
public class NewConstraint<T> where T : new()
{
    public T CreateNew()
    {
        return new T();
    }
}

// Interface Constraint
public class InterfaceConstraint<T> where T : IComparable<T>
{
    public bool IsGreaterThan(T first, T second)
    {
        return first.CompareTo(second) > 0;
    }
}

// Multiple Constraints
public class MultipleConstraints<T>
    where T : class, IDisposable, new()
{
    public void ProcessItem(T item)
    {
        // Processing logic
        item.Dispose();
    }
}
```

```csharp
// Base Class
public class Animal
{
    public virtual void MakeSound() { }
}

// Generic Class with Base Class Constraint
public class AnimalContainer<T> where T : Animal
{
    private T _animal;

    public AnimalContainer(T animal)
    {
        _animal = animal;
    }

    public void MakeAnimalSound()
    {
        _animal.MakeSound();
    }
}

// Usage Example
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow!");
    }
}
```

#### æ³›å‹æ¥å£

```csharp
// Generic Interface Definition
public interface IRepository<T>
{
    T GetById(int id);
    void Add(T item);
    void Update(T item);
    void Delete(int id);
    IEnumerable<T> GetAll();
}

// Implementing the Generic Interface
public class Repository<T> : IRepository<T> where T : class
{
    private readonly List<T> _items = new List<T>();

    public T GetById(int id)
    {
        // Implement retrieval logic
        return _items.FirstOrDefault();
    }

    public void Add(T item)
    {
        _items.Add(item);
    }

    public void Update(T item)
    {
        // Implement update logic
    }

    public void Delete(int id)
    {
        // Implement deletion logic
    }

    public IEnumerable<T> GetAll()
    {
        return _items;
    }
}
```

`C#` ä¸­çš„æ³›å‹æ”¯æŒåå˜å’Œé€†å˜ï¼Œä»è€Œåœ¨ç±»å‹ä¹‹é—´å®ç°æ›´çµæ´»çš„å…³ç³»ã€‚

```csharp
// Covariant Interface (out)
public interface IProducer<out T>
{
    T Produce();
}

// Contravariant Interface (in)
public interface IConsumer<in T>
{
    void Consume(T item);
}

// Implementation Example
public class Producer<T> : IProducer<T> where T : new()
{
    public T Produce()
    {
        return new T();
    }
}

public class Consumer<T> : IConsumer<T>
{
    public void Consume(T item)
    {
        Console.WriteLine($"Consuming {item}");
    }
}

// Using Covariance and Contravariance
public class VarianceExample
{
    public void DemonstrateVariance()
    {
        IProducer<string> stringProducer = new Producer<string>();
        IProducer<object> objectProducer = stringProducer; // Covariance

        IConsumer<object> objectConsumer = new Consumer<object>();
        IConsumer<string> stringConsumer = objectConsumer; // Contravariance
    }
}
```

`C#` ä¸­çš„æ³›å‹é€šè¿‡æä¾›åˆ›å»ºçµæ´»ä¸”ç±»å‹å®‰å…¨çš„ç»„ä»¶çš„æœºåˆ¶æ¥å¢å¼ºä»£ç çš„å¯é‡ç”¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚æ— è®ºæ˜¯ä½¿ç”¨æ³›å‹ç±»ã€æ–¹æ³•è¿˜æ˜¯æ¥å£ï¼Œç†è§£æ³›å‹å¯¹äºåœ¨ `C#` ä¸­æ„å»ºé«˜æ•ˆä¸”é€‚åº”æ€§å¼ºçš„è½¯ä»¶è§£å†³æ–¹æ¡ˆè‡³å…³é‡è¦ã€‚

## äº”ã€è¯­è¨€é›†æˆæŸ¥è¯¢ (LINQ) ğŸ“š

LINQ å…è®¸ä½¿ç”¨æŸ¥è¯¢è¡¨è¾¾å¼ä¸æ•°æ®äº¤äº’ï¼Œè€Œä¸ç®¡å…¶æ¥æºå¦‚ä½•ã€‚å®ƒæœ‰åŠ©äºè½»æ¾åœ°è¿‡æ»¤ã€æ’åºã€åˆ†ç»„å’Œè½¬æ¢æ•°æ®ï¼Œæä¾›ä¸€ç§æ— ç¼ä¸”é›†æˆçš„æ–¹å¼æ¥æŸ¥è¯¢å¯¹è±¡ã€æ•°æ®åº“å’Œ XML æ–‡æ¡£ã€‚

ç†è§£ LINQ è‡³å…³é‡è¦ï¼Œå› ä¸ºå®ƒæä¾›äº†ç»Ÿä¸€ä¸”ç‹¬ç«‹äºæ¨¡å‹çš„æŸ¥è¯¢åŠŸèƒ½ï¼Œç®€åŒ–äº†æ•°æ®æ“ä½œå’Œæ£€ç´¢è¿‡ç¨‹ï¼Œå¹¶ä¸”æä¾›å¢å¼ºçš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

åœ¨ `C#` ä¸­ï¼ŒLINQ æ˜¯ä¸€ç»„æ‰©å±•ï¼Œå…è®¸ç›´æ¥ä»ç¼–ç¨‹è¯­è¨€å¯¹å„ç§æ•°æ®æºæ‰§è¡ŒæŸ¥è¯¢ã€‚LINQ å¯ç”¨äºå¤„ç†é›†åˆã€XMLã€æ•°æ®åº“ç­‰ã€‚

### 1ã€åŸºç¡€ ğŸ“

#### æŸ¥è¯¢è¯­æ³•

```csharp
var query = from item in collection
            where item.Price > 100
            orderby item.Name
            select item;
```

#### æ–¹æ³•è¯­æ³•

```csharp
var query = collection
    .Where(x => x.Price > 100)
    .OrderBy(x => x.Name)
    .Select(x => x);
```

### 2ã€å¸¸ç”¨ LINQ æ“ä½œç¬¦ ğŸ“Š

- `Where`ï¼šæ­¤æ–¹æ³•ç”¨äºæ ¹æ®ç»™å®šè°“è¯è¿‡æ»¤é›†åˆã€‚å®ƒè¿”å›ä¸€ä¸ªæ–°é›†åˆï¼Œå…¶ä¸­ä»…åŒ…å«æ»¡è¶³æŒ‡å®šæ¡ä»¶çš„å…ƒç´ ã€‚

- `Select`ï¼šæ­¤æ–¹æ³•ç”¨äºæŠ•å½±æˆ–è½¬æ¢é›†åˆçš„å…ƒç´ ã€‚å®ƒè¿”å›ä¸€ä¸ªæ–°é›†åˆï¼Œå…¶ä¸­åŒ…å«å·²æ ¹æ®æŒ‡å®šå‡½æ•°æˆ–æŠ•å½±è¿›è¡Œè½¬æ¢çš„å…ƒç´ ã€‚

### 3ã€èšåˆæ“ä½œ ğŸ”—

```csharp
int count = numbers.Count();
int sum = numbers.Sum();
double average = numbers.Average();
int max = numbers.Max();
int min = numbers.Min();
```

### 4ã€åˆ†ç»„å’Œè¿æ¥ ğŸ“ˆ

```csharp
var groups = products.GroupBy(p => p.Category);

var joined = customers.Join(orders,
    c => c.Id,
    o => o.CustomerId,
    (c, o) => new { Customer = c, Order = o });
```

### 5ã€å»¶è¿Ÿæ‰§è¡Œä¸ç«‹å³æ‰§è¡Œ â°

LINQ ä¸­çš„å»¶è¿Ÿæ‰§è¡Œæ„å‘³ç€åœ¨æšä¸¾ç»“æœä¹‹å‰ä¸ä¼šå‘ç”Ÿå®é™…çš„æ•°æ®å¤„ç†æˆ–è®¡ç®—ã€‚å½“æ‚¨æ„å»º LINQ æŸ¥è¯¢æ—¶ï¼Œå®ƒåªæ˜¯åˆ›å»ºä¸€ä¸ªæŸ¥è¯¢å®šä¹‰ã€‚

```csharp
var query = numbers.Where(n => n > 3); // Query not executed yet
foreach (var num in query)
{
    Console.WriteLine(num); // Query executed here
}
```

å®é™…æ‰§è¡Œä¼šå»¶è¿Ÿï¼Œç›´åˆ°æ‚¨è¿­ä»£æŸ¥è¯¢ç»“æœï¼Œä¾‹å¦‚ä½¿ç”¨ foreach å¾ªç¯æˆ–ä½¿ç”¨ ToList() æˆ– ToArray() ç­‰æ–¹æ³•è½¬æ¢ç»“æœã€‚è¿™å¯ä»¥é€šè¿‡é¿å…ä¸å¿…è¦çš„è®¡ç®—æ¥æé«˜æ€§èƒ½ã€‚

```csharp
var result = numbers.Where(n => n > 3).ToList(); // Query executed immediately
```

> è°ƒç”¨ä»¥ä¸‹æ–¹æ³•ä¼šç«‹å³æ‰§è¡ŒæŸ¥è¯¢ï¼š
>
> - **â€‹`ToList()`â€‹**
> - **â€‹`ToArray()`â€‹**
> - **â€‹`Count()`â€‹**

ç„¶è€Œï¼Œç®¡ç†æ•°æ®å®é™…å®ç°çš„æ—¶åˆ»ï¼ˆå³è·å–æ•°æ®å¹¶å°†å…¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼‰éå¸¸é‡è¦ã€‚è¿‡æ—©å…·ä½“åŒ–æ•°æ®æœ‰æ—¶ä¼šæ¶ˆè€—æ›´å¤šèµ„æºï¼Œå°¤å…¶æ˜¯å½“æ•°æ®æºå¾ˆå¤§ï¼ˆä¾‹å¦‚æ•°æ®åº“ï¼‰æ—¶ã€‚åœ¨å†³å®šå…·ä½“åŒ–ç»“æœä»¥ä¼˜åŒ–èµ„æºä½¿ç”¨å’Œæ€§èƒ½ä¹‹å‰ï¼Œæ‚¨å¯èƒ½éœ€è¦å‘æŸ¥è¯¢é™„åŠ æ›´å¤šæ¡ä»¶æˆ–è¿‡æ»¤å™¨ã€‚

### 6ã€`All`ä¸ `Any` ğŸ”

ç”¨äºæ£€æŸ¥é›†åˆä¸­çš„å…ƒç´ ã€‚

- `All`ï¼šæ£€æŸ¥é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯å¦æ»¡è¶³ç‰¹å®šæ¡ä»¶ã€‚ä½¿ç”¨ `All` æ—¶ï¼Œæ‚¨éœ€è¦ç¡®ä¿é›†åˆçš„æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³ç‰¹å®šæ ‡å‡†ã€‚

- `Any`ï¼šæ£€æŸ¥é›†åˆä¸­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ æ»¡è¶³ç‰¹å®šæ¡ä»¶ã€‚ä½¿ç”¨ `Any` å½“æ‚¨éœ€è¦ç¡®å®šæ˜¯å¦æœ‰ä»»ä½•å…ƒç´ æ»¡è¶³ç‰¹å®šæ ‡å‡†æ—¶ã€‚

å½“é›†åˆä¸ºç©ºæ—¶ï¼Œä¼šå‘ç”Ÿä»¥ä¸‹æƒ…å†µï¼š

- `All`ï¼šå§‹ç»ˆè¿”å› trueï¼Œå› ä¸ºä¸å­˜åœ¨è¿åæ¡ä»¶çš„å…ƒç´ ã€‚è¿™å¯èƒ½çœ‹èµ·æ¥è¿åç›´è§‰ï¼Œä½†åœ¨æ²¡æœ‰ä»»ä½•è¦æ£€æŸ¥çš„å…ƒç´ çš„æƒ…å†µä¸‹ï¼Œå®ƒé»˜è®¤ä¸º trueã€‚

- `Any`ï¼šå§‹ç»ˆè¿”å› falseï¼Œå› ä¸ºä¸å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„å…ƒç´ ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æƒ³éªŒè¯åˆ—è¡¨ä¸­çš„æ‰€æœ‰æ•°å­—å‡ä¸ºæ­£æ•°ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ `All`ã€‚å¦‚æœæ‚¨è¦æ£€æŸ¥åˆ—è¡¨ä¸­æ˜¯å¦æœ‰è´Ÿæ•°ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ `Any`ã€‚

```csharp
int[] numbers = { 1, 3, 5, 8 };
bool hasEvenNumber = numbers.Any(n => n % 2 == 0);
Console.WriteLine($"Is there an even number? {hasEvenNumber}");
```

### 7ã€è‡ªå®šä¹‰ LINQ æ‰©å±•æ–¹æ³• ğŸ“

`IEnumerable` å’Œ `IQueryable` æ˜¯è¡¨ç¤º .NET ä¸­é›†åˆçš„ä¸¤ä¸ªä¸»è¦æ¥å£ã€‚è¿™å°±æ˜¯å®ƒä»¬çš„ä½œç”¨ï¼š

`IEnumerable`ï¼šåœ¨å†…å­˜ä¸­çš„å¯¹è±¡çº§åˆ«æ“ä½œã€‚å½“æ‚¨é’ˆå¯¹ `IEnumerable` æ¥å£æ‰§è¡Œ LINQ æŸ¥è¯¢æ—¶ï¼Œæ“ä½œæ˜¯åœ¨å†…å­˜ä¸­æ‰§è¡Œçš„ã€‚å®ƒé€‚åˆå¤„ç†å†…å­˜ä¸­çš„é›†åˆï¼Œä¾‹å¦‚æ•°ç»„æˆ–åˆ—è¡¨ã€‚

`IQueryable`ï¼šè®¾è®¡ç”¨äºä¸å¤–éƒ¨æ•°æ®æºï¼ˆä¾‹å¦‚æ•°æ®åº“ï¼‰äº¤äº’ã€‚ä½¿ç”¨ `IQueryable` è¿›è¡Œçš„æŸ¥è¯¢å°†è½¬æ¢ä¸ºç‰¹å®šäºæ•°æ®æºçš„æŸ¥è¯¢ï¼ˆä¾‹å¦‚å…³ç³»æ•°æ®åº“çš„ SQLï¼‰ã€‚è¯¥æ¥å£å…è®¸å»¶è¿Ÿæ‰§è¡Œå’Œå†…å­˜ä¸è¶³ (OOM) æ•°æ®æŸ¥è¯¢ï¼Œä½¿å…¶å¯¹äºå¤§å‹æ•°æ®é›†ï¼ˆå°¤å…¶æ˜¯æ•°æ®åº“ï¼‰éå¸¸é«˜æ•ˆã€‚

è¿™ä¸¤ä¸ªæ¥å£çš„ä¸»è¦åŒºåˆ«åœ¨äºæ‰§è¡Œä½ç½®ï¼š`IEnumerable` å¤„ç†å†…å­˜ä¸­çš„æ•°æ®ã€‚åŒæ—¶ï¼Œ`IQueryable` å…è®¸æ„å»ºè¡¨è¾¾å¼æ ‘ï¼Œè¯¥è¡¨è¾¾å¼æ ‘å¯ä»¥è½¬æ¢ä¸ºé€‚åˆå¤–éƒ¨æ•°æ®æºçš„æŸ¥è¯¢ï¼Œä¾‹å¦‚æ•°æ®åº“çš„ SQLã€‚ç„¶åï¼Œå®ƒå°†è§£æåçš„æŸ¥è¯¢å‘é€åˆ°æ•°æ®æºè¿›è¡Œå¤„ç†ï¼Œå¹¶ä»¥ `IEnumerable` å½¢å¼è·å–ç»“æœã€‚

```csharp
public class BasicConcepts
{
    // IEnumerable: In-memory collection operations
    // IQueryable: Database query operations

    public void CompareInterfaces()
    {
        // IEnumerable - executed in memory
        IEnumerable<int> enumerable = Enumerable.Range(1, 100);
        var enumResult = enumerable
            .Where(x => x > 50)    // Filter in memory
            .Select(x => x * 2);   // Transform in memory

        // IQueryable - executed at the data source
        IQueryable<int> queryable = Enumerable.Range(1, 100).AsQueryable();
        var queryResult = queryable
            .Where(x => x > 50)    // Translated to SQL WHERE clause
            .Select(x => x * 2);   // Translated to SQL SELECT clause
    }
}
```

### 8ã€ä¼˜åŒ– ğŸ’»

ä¼˜åŒ– LINQ æŸ¥è¯¢ï¼Œå°¤å…¶æ˜¯é’ˆå¯¹å¤§é‡æ•°æ®é›†çš„æŸ¥è¯¢ï¼Œå¯ä»¥é€šè¿‡å¤šç§æ–¹æ³•æ¥å®ç°ï¼š

- å°½å¯èƒ½åˆ©ç”¨å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿æŸ¥è¯¢ä»…åœ¨ç»“æœæ˜¯çœŸæ­£éœ€è¦çš„æƒ…å†µä¸‹æ‰§è¡Œã€‚è¿™é¿å…äº†ä¸å¿…è¦çš„è®¡ç®—ã€‚

- é€‰æ‹©ä¸ºæ‚¨çš„ç‰¹å®šç”¨ä¾‹é‡èº«å®šåˆ¶çš„æœ€æœ‰æ•ˆçš„é›†åˆç±»å‹ï¼Œå› ä¸ºåº•å±‚æ•°æ®ç»“æ„ä¼šå½±å“æ€§èƒ½ã€‚

- åœ¨å¯è¡Œçš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨ `Take` ç­‰æ–¹æ³•é™åˆ¶ç»“æœæ•°æ®é›†çš„å¤§å°ï¼Œä»¥é¿å…å¤„ç†è¶…å‡ºå¿…è¦çš„æ•°æ®ã€‚

- é¿å…æˆ–æ˜æ™ºåœ°ä½¿ç”¨åµŒå¥—æŸ¥è¯¢ã€‚ç”±äºå¤šè½®æ•°æ®æ£€ç´¢æˆ–è®¡ç®—ï¼Œå®ƒä»¬å¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ã€‚

- å¦‚æœæ‚¨é¢„è®¡å¯¹æ•°æ®è¿›è¡Œå¤šæ¬¡æ“ä½œï¼Œè¯·ä½¿ç”¨ `ToArray` æˆ– `ToList` ç­‰æ–¹æ³•å°†ç»“æœå…·ä½“åŒ–åˆ°å†…å­˜ä¸­ã€‚è¿™å¯ä»¥é˜²æ­¢é‡å¤æ‰§è¡Œç›¸åŒçš„ LINQ æŸ¥è¯¢ã€‚

## å…­ã€Lambda ğŸ‘€

Lambda è¡¨è¾¾å¼å’ŒåŒ¿åå‡½æ•°æ˜¯ `C#` ä¸­çš„åŸºæœ¬æ¦‚å¿µï¼Œå®ƒä»¬å…è®¸å°±åœ°å£°æ˜å’Œå®šä¹‰å‡½æ•°ï¼Œé€šå¸¸ç”¨ä½œå…¶ä»–å‡½æ•°çš„å‚æ•°ã€‚

å®ƒä»¬å› èƒ½å¤Ÿæä¾›ç®€æ´ã€å¯Œæœ‰è¡¨ç°åŠ›çš„è¯­æ³•æ¥è¡¨ç¤ºåŠŸèƒ½è€Œé—»åï¼Œå°¤å…¶æ˜¯ä¸é«˜é˜¶å‡½æ•°å’Œ LINQ ä¸€èµ·ä½¿ç”¨æ—¶ã€‚

### 1ã€Lambda è¡¨è¾¾å¼ ğŸ”

`(parameters) => expression`

```csharp
public class LambdaBasics
{
    public void BasicSyntax()
    {
        // 1. No-parameter Lambda
        Action sayHello = () => Console.WriteLine("Hello");

        // 2. Single-parameter Lambda
        Func<int, int> square = x => x * x;

        // 3. Multiple-parameter Lambda
        Func<int, int, int> add = (x, y) => x + y;

        // 4. Lambda with a statement block
        Func<int, int, int> multiply = (x, y) =>
        {
            Console.WriteLine($"Multiplying {x} and {y}");
            return x * y;
        };

        // 5. Type-declared Lambda
        Func<double, double, double> divide = (double x, double y) => x / y;

        // Usage examples
        sayHello();                    // Output: Hello
        Console.WriteLine(square(5));  // Output: 25
        Console.WriteLine(add(3, 4));  // Output: 7
    }
}
```

### 2ã€Lambda é—­åŒ… ğŸ”—

lambda è¡¨è¾¾å¼å’ŒåŒ¿åæ–¹æ³•ä¸Šä¸‹æ–‡ä¸­çš„é—­åŒ…æ˜¯æŒ‡è¿™äº›æ„é€ ä»å…¶å°é—­èŒƒå›´æ•è·å¹¶ä¿ç•™å¯¹å…¶å˜é‡çš„è®¿é—®çš„èƒ½åŠ›ã€‚

æ•è·çš„å˜é‡ä»¥å³ä½¿åœ¨å£°æ˜å®ƒä»¬çš„æ–¹æ³•å®Œæˆæ‰§è¡Œåä»å¯è®¿é—®å’Œå¯å˜çš„æ–¹å¼å­˜å‚¨ã€‚

å¦‚æœæ²¡æœ‰æ­£ç¡®ç†è§£ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ„å¤–çš„è¡Œä¸ºï¼Œå°¤å…¶æ˜¯åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ï¼Œå…¶ä¸­é—­åŒ…å¯èƒ½ä¼šå¼•å…¥è·¨çº¿ç¨‹çš„å…±äº«çŠ¶æ€ã€‚

```csharp
public class LambdaClosure
{
    public void ClosureExamples()
    {
        // Basic closure
        int multiplier = 10;
        Func<int, int> multiply = x => x * multiplier;

        // Closure trap
        var actions = new List<Action>();
        for (int i = 0; i < 5; i++)
        {
            // Incorrect way - all actions will use the final value of i
            actions.Add(() => Console.WriteLine(i));
        }

        // Correct way
        for (int i = 0; i < 5; i++)
        {
            int temp = i;
            actions.Add(() => Console.WriteLine(temp));
        }

        // Counter closure
        Func<int> counter = CreateCounter();
        Console.WriteLine(counter()); // 1
        Console.WriteLine(counter()); // 2
    }

    private Func<int> CreateCounter()
    {
        int count = 0;
        return () => ++count;
    }
}
```

### 3ã€Lambda è¡¨è¾¾å¼æ ‘ ğŸŒ³

Lambda è¡¨è¾¾å¼æ ‘æ˜¯ä¸€ç§ä»¥æ ‘å½¢æ•°æ®ç»“æ„æ¥è¡¨ç¤ºä»£ç çš„æ–¹å¼ï¼Œå¸¸ç”¨äºåŠ¨æ€æ„å»ºæŸ¥è¯¢ã€‚

```csharp
public class ExpressionTrees
{
    public void ExpressionTreeExamples()
    {
        // Create an expression tree
        Expression<Func<int, bool>> isEven = x => x % 2 == 0;

        // Manually construct an expression tree
        ParameterExpression param = Expression.Parameter(typeof(int), "x");
        BinaryExpression operation = Expression.Equal(
            Expression.Modulo(param, Expression.Constant(2)),
            Expression.Constant(0)
        );
        var manualIsEven = Expression.Lambda<Func<int, bool>>(
            operation,
            param
        );

        // Compile and execute
        var compiled = isEven.Compile();
        bool result = compiled(4); // true
    }
}
```

### 4ã€å°† Lambda ä¸ LINQ ç»“åˆä½¿ç”¨ ğŸ“ˆ

Lambda è¡¨è¾¾å¼åœ¨ LINQ ä¸­çš„åº”ç”¨éå¸¸å¹¿æ³›ï¼Œå®ƒä½¿æŸ¥è¯¢è¯­æ³•æ›´ç®€æ´å’Œæ¸…æ™°ã€‚

```csharp
public class LinqWithLambda
{
    private List<int> numbers = Enumerable.Range(1, 10).ToList();
    private List<string> words = new List<string>
    {
        "apple", "banana", "cherry", "date"
    };

    public void LinqExamples()
    {
        // Where
        var evenNumbers = numbers.Where(n => n % 2 == 0);

        // Select
        var doubled = numbers.Select(n => n * 2);

        // OrderBy
        var ordered = words.OrderBy(w => w.Length);

        var filteredAndOrdered = numbers
            .Where(n => n > 5)
            .OrderByDescending(n => n)
            .Select(n => n * n);

        var grouped = words
            .GroupBy(w => w[0])
            .Select(g => new
            {
                FirstLetter = g.Key,
                Words = g.ToList()
            });
    }
}
```
