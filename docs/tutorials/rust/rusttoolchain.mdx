---
sidebar_label: II. Rust Toolchain
title: II. Rust Toolchain
sidebar_position: 3
---

| Toolchain/version manager | Rust compiler | Code formatter | Linter   | Package manager | Package registry |
|---------------------------|---------------|----------------|----------|-----------------|------------------|
| `rustup`                  | `rustc`       | `rustfmt`      | `clippy` | `cargo`         | `crates.io`      |

| å·¥å…·é“¾/ç‰ˆæœ¬ç®¡ç†å™¨ | Rust ç¼–è¯‘å™¨ | ä»£ç æ ¼å¼åŒ–å·¥å…·   | ä»£ç æ£€æŸ¥å·¥å…·   | åŒ…ç®¡ç†å™¨    | åŒ…æ³¨å†Œä¸­å¿ƒ       |
|-----------|----------|-----------|----------|---------|-------------|
| `rustup`  | `rustc`  | `rustfmt` | `clippy` | `cargo` | `crates.io` |

## 1. Introduction ç®€å•ä»‹ç» ðŸ’¡

- `rustup`: the Rust toolchain installer and updater. This tool is used to install and updateÂ `rustc`Â andÂ `cargo`Â when new versions of Rust are released. In addition,Â `rustup`Â can also download documentation for the standard library. You can have multiple versions of Rust installed at once andÂ `rustup`Â will let you switch between them as needed.
- `rustup`ï¼šRust å·¥å…·é“¾çš„å®‰è£…å’Œæ›´æ–°å·¥å…·ã€‚è¿™ä¸ªå·¥å…·ç”¨äºŽåœ¨å‘å¸ƒæ–°ç‰ˆæœ¬çš„ Rust æ—¶å®‰è£…å’Œæ›´æ–° `rustc` å’Œ `cargo`ã€‚æ­¤å¤–ï¼Œ`rustup` è¿˜å¯ä»¥ä¸‹è½½æ ‡å‡†åº“çš„æ–‡æ¡£ã€‚ä½ å¯ä»¥åŒæ—¶å®‰è£…å¤šä¸ªç‰ˆæœ¬çš„ Rustï¼Œå¹¶ä½¿ç”¨ `rustup` åœ¨å®ƒä»¬ä¹‹é—´åˆ‡æ¢ã€‚

- `rustc`: the Rust compiler which turnsÂ `.rs`Â files into binaries and other intermediate formats.
- `rustc`ï¼šRust ç¼–è¯‘å™¨ï¼Œç”¨äºŽå°† `.rs` æ–‡ä»¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶æˆ–å…¶ä»–ä¸­é—´æ ¼å¼ã€‚

- `rustfmt`: a tool for formatting Rust code according to style guidelines. It ensures that Rust code is consistent and adheres to community standards.
- `rustfmt`ï¼šç”¨äºŽæ ¹æ®æ ·å¼æŒ‡å—æ ¼å¼åŒ– Rust ä»£ç çš„å·¥å…·ã€‚å®ƒç¡®ä¿ Rust ä»£ç çš„ä¸€è‡´æ€§å¹¶ç¬¦åˆç¤¾åŒºæ ‡å‡†ã€‚

- `clippy`: a collection of lints to catch common mistakes and improve your Rust code. It provides suggestions for idiomatic Rust usage and helps maintain code quality.
- `clippy`ï¼šä¸€ç»„ç”¨äºŽæ•æ‰å¸¸è§é”™è¯¯å¹¶æ”¹è¿› Rust ä»£ç çš„ lint é›†åˆã€‚å®ƒæä¾›æƒ¯ç”¨çš„ Rust ä½¿ç”¨å»ºè®®ï¼Œå¹¶å¸®åŠ©ç»´æŠ¤ä»£ç è´¨é‡ã€‚

- `cargo`: the Rust dependency manager and build tool. Cargo knows how to download dependencies, usually hosted onÂ [https://crates.io](https://crates.io/), and it will pass them toÂ `rustc`Â when building your project. Cargo also comes with a built-in test runner which is used to execute unit tests.
- `cargo`ï¼šRust çš„ä¾èµ–ç®¡ç†å™¨å’Œæž„å»ºå·¥å…·ã€‚Cargo å¯ä»¥ä¸‹è½½ä¾èµ–é¡¹ï¼ˆé€šå¸¸æ‰˜ç®¡åœ¨ [https://crates.io](https://crates.io/) ä¸Šï¼‰ï¼Œå¹¶åœ¨æž„å»ºé¡¹ç›®æ—¶å°†è¿™äº›ä¾èµ–é¡¹ä¼ é€’ç»™ `rustc`ã€‚Cargo è¿˜å†…ç½®äº†æµ‹è¯•è¿è¡Œå™¨ï¼Œç”¨äºŽæ‰§è¡Œå•å…ƒæµ‹è¯•ã€‚

- `crates.io`: the official package registry for Rust, where developers can publish, discover, and manage Rust libraries (crates). It serves as the primary source for Rust packages and dependencies.

- `crates.io`ï¼šRust çš„å®˜æ–¹åŒ…æ³¨å†Œè¡¨ï¼Œå¼€å‘è€…å¯ä»¥åœ¨è¿™é‡Œå‘å¸ƒã€å‘çŽ°å’Œç®¡ç† Rust åº“ï¼ˆcratesï¼‰ã€‚å®ƒæ˜¯ Rust åŒ…å’Œä¾èµ–é¡¹çš„ä¸»è¦æ¥æºã€‚

## 2. `Editions` ðŸ“š

Editions in Rust are a structured way to introduce new features and improvements while maintaining backward compatibility. This ensures that code written in older editions will still compile with newer compilers.
Rust ç‰ˆæœ¬æ˜¯ä¸€ç§ç»“æž„åŒ–çš„æ–¹æ³•ï¼Œç”¨äºŽå¼•å…¥æ–°åŠŸèƒ½å’Œæ”¹è¿›ï¼ŒåŒæ—¶ä¿æŒå‘åŽå…¼å®¹æ€§ã€‚è¿™ç¡®ä¿äº†ç”¨æ—§ç‰ˆæœ¬ç¼–å†™çš„ä»£ç ä»å¯ä»¥ä½¿ç”¨è¾ƒæ–°çš„ç¼–è¯‘å™¨è¿›è¡Œç¼–è¯‘ã€‚

Rust editions are released every three years, allowing significant changes to be introduced without breaking existing code.
Rust ç‰ˆæœ¬æ¯ä¸‰å¹´å‘å¸ƒä¸€æ¬¡ï¼Œä½¿å¾—åœ¨ä¸ç ´åçŽ°æœ‰ä»£ç çš„æƒ…å†µä¸‹å¯ä»¥å¼•å…¥é‡å¤§æ›´æ”¹ã€‚

So far, Rust has had three editions: 2015, 2018, and 2021. Each edition introduces new syntax, features, and improvements.
åˆ°ç›®å‰ä¸ºæ­¢ï¼ŒRust å·²ç»å‘å¸ƒäº†ä¸‰ä¸ªç‰ˆæœ¬ï¼š2015 å¹´ã€2018 å¹´å’Œ 2021 å¹´ã€‚æ¯ä¸ªç‰ˆæœ¬éƒ½å¼•å…¥äº†æ–°çš„è¯­æ³•ã€åŠŸèƒ½å’Œæ”¹è¿›ã€‚

The edition is specified in the Cargo.toml file under the `[package]` section, guiding the Rust compiler on which edition's rules to apply.
ç‰ˆæœ¬åœ¨ Cargo.toml æ–‡ä»¶çš„ `[package]` éƒ¨åˆ†æŒ‡å®šï¼ŒæŒ‡å¯¼ Rust ç¼–è¯‘å™¨åº”ç”¨å“ªä¸ªç‰ˆæœ¬çš„è§„åˆ™ã€‚

Code from different editions can coexist within the same project, allowing for gradual migration to newer editions.
ä¸åŒç‰ˆæœ¬çš„ä»£ç å¯ä»¥åœ¨åŒä¸€é¡¹ç›®ä¸­å…±å­˜ï¼Œä»Žè€Œå®žçŽ°å‘è¾ƒæ–°ç‰ˆæœ¬çš„é€æ­¥è¿ç§»ã€‚

Tools like `cargo fix` assist in migrating code to a newer edition by automatically applying necessary changes.
`cargo fix` ç­‰å·¥å…·é€šè¿‡è‡ªåŠ¨åº”ç”¨å¿…è¦çš„æ›´æ”¹ï¼Œå¸®åŠ©å°†ä»£ç è¿ç§»åˆ°è¾ƒæ–°çš„ç‰ˆæœ¬ã€‚

Editions enable Rust to evolve and improve without disrupting existing projects, making it easier for developers to adopt new features at their own pace.
ç‰ˆæœ¬ä½¿ Rust èƒ½å¤Ÿåœ¨ä¸å¹²æ‰°çŽ°æœ‰é¡¹ç›®çš„æƒ…å†µä¸‹å‘å±•å’Œæ”¹è¿›ï¼Œä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿæ›´è½»æ¾åœ°æŒ‰ç…§è‡ªå·±çš„èŠ‚å¥é‡‡ç”¨æ–°åŠŸèƒ½ã€‚

## 3. `Crate` ðŸ“¦

Rust implements code modularity and organization through its `crate` system.
Rust é€šè¿‡ `crate` ç³»ç»Ÿå®žçŽ°ä»£ç æ¨¡å—åŒ–å’Œç»„ç»‡ã€‚

`crates`, the fundamental compilation units in Rust, can be compiled into executable binaries or libraries. This structure promotes code modularity, reusability and separation of concerns.
`crate` æ˜¯ Rust çš„åŸºæœ¬ç¼–è¯‘å•å…ƒï¼Œå¯è¢«ç¼–è¯‘ä¸ºå¯æ‰§è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶æˆ–åº“æ–‡ä»¶ã€‚è¿™ç§ç»“æž„ä¿ƒè¿›äº†ä»£ç çš„æ¨¡å—åŒ–ã€å¯é‡ç”¨æ€§å’Œå…³æ³¨ç‚¹åˆ†ç¦»ã€‚

The `crate` system also facilitates code sharing, enabling developers to reuse functional modules across different projects, thereby enhancing development efficiency and reducing duplication of effort. Through `crate`, Rust provides robust support for structuring large projects and collaborative development.
`crate` ç³»ç»Ÿè¿˜æ”¯æŒä»£ç å…±äº«ï¼Œå…è®¸å¼€å‘è€…åœ¨ä¸åŒé¡¹ç›®é—´å¤ç”¨åŠŸèƒ½æ¨¡å—ï¼Œæé«˜å¼€å‘æ•ˆçŽ‡å¹¶å‡å°‘é‡å¤å·¥ä½œã€‚é€šè¿‡ `crate`ï¼ŒRust ä¸ºå¤§åž‹é¡¹ç›®çš„ç»“æž„åŒ–å’Œåä½œå¼€å‘æä¾›äº†å¼ºå¤§çš„æ”¯æŒã€‚

### Binary Crate äºŒè¿›åˆ¶ crate ðŸ’»

Usually `main.rs` is used as the entry point, which is compiled to produce an executable.
é€šå¸¸ä»¥`main.rs`ä½œä¸ºå…¥å£ç‚¹ï¼Œç¼–è¯‘åŽç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚

```rust
// src/main.rs
fn main() {
    println!("Hello, world!");
}
```

### Library Crate ðŸ“¦

Usually `lib.rs` is the main file, which is compiled to generate libraries for use by other programs.
é€šå¸¸ä»¥`lib.rs`ä¸ºä¸»æ–‡ä»¶ï¼Œç¼–è¯‘åŽç”Ÿæˆä¾›å…¶ä»–ç¨‹åºä½¿ç”¨çš„åº“ã€‚

```rust
// src/lib.rs
pub fn greet(name: &str) -> String {
    println!("Hello, {}!", name);
}
```

This crate can be referenced by other `crate`.
è¿™ä¸ªåº“å¯ä»¥è¢«å…¶ä»– `crate` å¼•ç”¨ã€‚

```rust
// src/main.rs
use my_library::greet;

fn main() {
    let message = greet("Alice");
    println!("{}", message);
}
```

## 4. `Modules` ðŸ“š

Modules in Rust are similar to namespaces in C++ and packages in Java.
Rust ä¸­çš„æ¨¡å—ï¼Œç±»ä¼¼ C++ ä¸­çš„å‘½åç©ºé—´ï¼ŒJava è¯­è¨€ä¸­çš„åŒ…ã€‚

In Rust, a singleÂ `crate`Â can contain multiple modules.
Rust è¯­è¨€ä¸­ä¸€ä¸ª `crate` å¯ä»¥å­˜æ”¾å¤šä¸ªæ¨¡å—ã€‚

When we talk about functional modules, we're referring to grouping functions or structures based on their functionality. It's common to organize similar functions, or functions and structures that implement the same functionality or work together to implement a functionality, into a single module.

æˆ‘ä»¬å¸¸è¯´åŠŸèƒ½æ¨¡å—ï¼Œå°±æ˜¯ç”¨äºŽå°†å‡½æ•°æˆ–ç»“æž„ä½“æŒ‰ç…§åŠŸèƒ½åˆ†ç»„ã€‚ä¹Ÿå¸¸å¸¸æŠŠç›¸ä¼¼çš„å‡½æ•°æˆ–è€…å®žçŽ°ç›¸åŒåŠŸèƒ½çš„æˆ–è€…å…±åŒå®žçŽ°ä¸€ä¸ªåŠŸèƒ½çš„å‡½æ•°å’Œç»“æž„ä½“åˆ’åˆ†åˆ°ä¸€ä¸ªæ¨¡å—ä¸­ã€‚

### Define modules å®šä¹‰æ¨¡å— ðŸ“¦

```rust
mod module_name {
   fn function_name() {
      // â€¦â€¦
   }
}
```

In Rust, modules are private by default. If a module or a function within a module needs to be exported for external use, theÂ `pub`Â keyword must be added. Private modules cannot be called by other external modules or programs. All functions in a private module must be private, while a public module can have both public and private functions.

Rust è¯­è¨€ä¸­çš„æ¨¡å—é»˜è®¤æ˜¯ç§æœ‰çš„ã€‚å¦‚æžœä¸€ä¸ªæ¨¡å—æˆ–è€…æ¨¡å—å†…çš„å‡½æ•°éœ€è¦å¯¼å‡ºä¸ºå¤–éƒ¨ä½¿ç”¨ï¼Œåˆ™éœ€è¦æ·»åŠ  Â `pub`Â  å…³é”®å­—ã€‚ç§æœ‰çš„æ¨¡å—ä¸èƒ½ä¸ºå¤–éƒ¨å…¶å®ƒæ¨¡å—æˆ–ç¨‹åºæ‰€è°ƒç”¨ã€‚ç§æœ‰æ¨¡å—çš„æ‰€æœ‰å‡½æ•°éƒ½å¿…é¡»æ˜¯ç§æœ‰çš„ï¼Œè€Œå…¬å¼€çš„æ¨¡å—ï¼Œåˆ™å³å¯ä»¥æœ‰å…¬å¼€çš„å‡½æ•°ä¹Ÿå¯ä»¥æœ‰ç§æœ‰çš„å‡½æ•°ã€‚

```rust
pub mod public_module {
   pub fn public_function() {
      // â€¦â€¦
   }
   fn private_function() {
      // â€¦â€¦
   }
}
mod private_module {
   fn private_function() {
	   // â€¦â€¦
   }
}
```

### Call module è°ƒç”¨æ¨¡å— ðŸ“ž

```rust
use pub_module::function_name;
use å…¬å¼€çš„æ¨¡å—å::å‡½æ•°å;
```

Create library åˆ›å»ºç±»åº“ï¼š
`cargo new â€“lib mylib`

```rust
// src/lib.rs

/// Adds two numbers and returns the result.
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// Multiplies two numbers and returns the result.
pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

Go to the mylib directory and execute `cargo build`.
è¿›å…¥ mylib ç›®å½•æ‰§è¡Œ` cargo build`

Open the root directory Cargo.toml
æ‰“å¼€æ ¹ç›®å½• Cargo.toml

```toml
[dependencies]
mylib = { path = "..//mylib" }
```

```rust
// src/main.rs
use mylib::{add, multiply};

fn main() {
    let sum = add(5, 10);
    let product = multiply(5, 10);

    println!("Sum: {}", sum);
    println!("Product: {}", product);
}
```

Rust allows nesting of one module within another, or, in other words, multiple levels of modules. To call or use a nested module use two colons (`::`) to splice modules from left to right, from outside to inside.

Rust å…è®¸ä¸€ä¸ªæ¨¡å—ä¸­åµŒå¥—å¦ä¸€ä¸ªæ¨¡å—ï¼Œæ¢ç§è¯´æ³•ï¼Œå°±æ˜¯å…è®¸å¤šå±‚çº§æ¨¡å—ã€‚è°ƒç”¨æˆ–ä½¿ç”¨åµŒå¥—æ¨¡å—çš„æ–¹æ³•ä½¿ç”¨ä¸¤ä¸ªå†’å· (`::`) ä»Žå·¦åˆ°å³æ‹¼æŽ¥ä»Žå¤–åˆ°å†…çš„æ¨¡å—å³å¯ã€‚

```rust
use mod1::mod2::mod3::method_name;

fn main() {
    method_name();
}
```

```rust
use mod1::mod2::mod3::æ–¹æ³•å;

fn main() {
    æ–¹æ³•å();
}
```

### Path è·¯å¾„ ðŸ›¤

Absolute path: start at crate root, use crate name or the literal value crate;
ç»å¯¹è·¯å¾„ï¼šä»Ž crate root å¼€å§‹ï¼Œä½¿ç”¨ crate åæˆ–å­—é¢å€¼ crateï¼›

Relative path: start from the current module, use self, super or the identifier of the current module;
ç›¸å¯¹è·¯å¾„ï¼šä»Žå½“å‰æ¨¡å—å¼€å§‹ï¼Œä½¿ç”¨ self ã€super æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦ï¼›

If the defined part and the used part always move together, use a relative path; if they can be detached independently, use an absolute path.
å¦‚æžœå®šä¹‰çš„éƒ¨åˆ†å’Œä½¿ç”¨çš„éƒ¨åˆ†æ€»æ˜¯ä¸€èµ·ç§»åŠ¨ï¼Œç”¨ç›¸å¯¹è·¯å¾„ï¼Œå¯ä»¥ç‹¬ç«‹æ‹†è§£å‡ºæ¥ï¼Œç”¨ç»å¯¹è·¯å¾„ã€‚

```
my_crate
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ utils.rs
```

```rust
// src/utils.rs
pub fn greet() {
    println!("Hello!");
}
```

```rust
// src/lib.rs
pub mod utils;

fn main() {
    my_crate::utils::greet();
    crate::utils::greet();
}
```

```
my_crate
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ module_a.rs
â”‚   â””â”€â”€ module_b.rs
```

```rust
// src/module_a.rs
pub fn function_a() {
    println!("Function A");
    self::function_b();
}

pub fn function_b() {
    println!("Function B");
}
```

```rust
// src/module_b.rs
pub fn call_function_a() {
    super::module_a::function_a();
}
```

```rust
// src/lib.rs
pub mod module_a;
pub mod module_b;

fn main() {
    module_b::call_function_a();
}
```

## 5. `Cargo` ðŸš¢

`Cargo`, Rustâ€™s package manager and build system, simplifies many tasks associated with managing dependencies, compiling packages, and distributing software.Â This ecosystem makes it easy for developers to share libraries, streamline their build processes, and manage multiple projects with ease.Â 
`Cargo` æ˜¯ Rust çš„åŒ…ç®¡ç†å™¨å’Œæž„å»ºç³»ç»Ÿï¼Œå®ƒç®€åŒ–äº†ç®¡ç†ä¾èµ–é¡¹ã€ç¼–è¯‘åŒ…å’Œåˆ†å‘è½¯ä»¶ç­‰è®¸å¤šä»»åŠ¡ã€‚è¿™ä¸ªç”Ÿæ€ç³»ç»Ÿä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿè½»æ¾å…±äº«åº“ã€ç®€åŒ–æž„å»ºè¿‡ç¨‹å¹¶è½»æ¾ç®¡ç†å¤šä¸ªé¡¹ç›®ã€‚

```
Moreover, Rustâ€™s compiler is renowned for its helpful error messages that not only tell you what went wrong but also suggest how to fix it.
æ­¤å¤–ï¼ŒRust çš„ç¼–è¯‘å™¨å› å…¶æœ‰ç”¨çš„é”™è¯¯æ¶ˆæ¯è€Œé—»åï¼Œä¸ä»…å‘Šè¯‰ä½ å‡ºäº†ä»€ä¹ˆé—®é¢˜ï¼Œè¿˜å»ºè®®å¦‚ä½•ä¿®å¤ã€‚
```

`Cargo` simplifies the Rust development workflow by managing project creation, building, and dependency management.
`Cargo` é€šè¿‡ç®¡ç†é¡¹ç›®åˆ›å»ºã€æž„å»ºå’Œä¾èµ–é¡¹ç®¡ç†æ¥ç®€åŒ– Rust å¼€å‘å·¥ä½œæµç¨‹ã€‚

### Command âŒ¨ï¸

```
The `cargo new` command initializes a new Rust project with a default directory structure.
`cargo new` å‘½ä»¤ä½¿ç”¨é»˜è®¤ç›®å½•ç»“æž„åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ Rust é¡¹ç›®ã€‚

Adding dependencies is straightforward; you modify the `Cargo.toml` file, and `Cargo` handles fetching and compiling the necessary `crates`.
æ·»åŠ ä¾èµ–é¡¹å¾ˆç®€å•ï¼›æ‚¨ä¿®æ”¹ `Cargo.toml` æ–‡ä»¶ï¼Œ`Cargo` ä¼šå¤„ç†èŽ·å–å’Œç¼–è¯‘å¿…è¦çš„ `crate`ã€‚

The `cargo build` command compiles the project, and `cargo run` compiles and runs the project. This seamless integration makes Rust development more efficient and organized.
`cargo build` å‘½ä»¤ç¼–è¯‘é¡¹ç›®ï¼Œ`cargo run` ç¼–è¯‘å¹¶è¿è¡Œé¡¹ç›®ã€‚è¿™ç§æ— ç¼é›†æˆä½¿ Rust å¼€å‘æ›´åŠ é«˜æ•ˆå’Œæœ‰ç»„ç»‡ã€‚

`Cargo` also supports running tests with `cargo test`, generating documentation with `cargo doc`, and publishing libraries to `crates.io` with `cargo publish`. Its comprehensive feature set and ease of use make it a crucial tool in the Rust ecosystem.
`Cargo` è¿˜æ”¯æŒä½¿ç”¨ `cargo test` è¿è¡Œæµ‹è¯•ï¼Œä½¿ç”¨ `cargo doc` ç”Ÿæˆæ–‡æ¡£ï¼Œä»¥åŠä½¿ç”¨`cargo publish` å°†åº“å‘å¸ƒåˆ° `crates.io`ã€‚å…¶å…¨é¢çš„åŠŸèƒ½é›†å’Œæ˜“ç”¨æ€§ä½¿å…¶æˆä¸º Rust ç”Ÿæ€ç³»ç»Ÿä¸­çš„é‡è¦å·¥å…·ã€‚

The `cargo --list` command lists all available `cargo` subcommands along with brief descriptions, helping developers quickly understand the features and options provided by `cargo` for more efficient management of Rust projects.

`cargo --list` æ­¤å‘½ä»¤åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„ `cargo` å­å‘½ä»¤åŠå…¶ç®€è¦è¯´æ˜Žï¼Œå¸®åŠ©å¼€å‘è€…å¿«é€Ÿäº†è§£ `cargo` æä¾›çš„åŠŸèƒ½å’Œé€‰é¡¹ï¼Œä»¥ä¾¿æ›´é«˜æ•ˆåœ°ç®¡ç† Rust é¡¹ç›®ã€‚

UseÂ `cargo check`Â to quickly check your project for errors, useÂ `cargo build`Â to compile it without running it. You will find the output inÂ `target/debug/`Â for a normal debug build. UseÂ `cargo build --release`Â to produce an optimized release build inÂ `target/release/`.
ä½¿ç”¨ `cargo check` å¿«é€Ÿæ£€æŸ¥é¡¹ç›®æ˜¯å¦æœ‰é”™è¯¯ï¼Œä½¿ç”¨ `cargo build` æ— éœ€è¿è¡Œå³å¯ç¼–è¯‘ã€‚ä½ å¯ä»¥åœ¨ `target/debug/` ä¸­æ‰¾åˆ°æ­£å¸¸è°ƒè¯•ç¼–è¯‘çš„è¾“å‡ºç»“æžœã€‚ä½¿ç”¨ `cargo build --release` å¯ä»¥åœ¨ `target/release/` ä¸­ç”Ÿæˆç»è¿‡ä¼˜åŒ–çš„å‘å¸ƒç‰ˆæœ¬ã€‚

`--verbose`Â is a common command-line parameter used to make a program output more runtime information, allowing for a better understanding of the program's operational state and more detailed debugging. The specific meaning and behavior may vary depending on the particular program.

`--verbose`Â æ˜¯ä¸€ä¸ªå¸¸è§çš„å‘½ä»¤è¡Œå‚æ•°ï¼Œç”¨äºŽè®©ç¨‹åºè¾“å‡ºæ›´å¤šçš„è¿è¡Œæ—¶ä¿¡æ¯ï¼Œä»¥ä¾¿äºŽæ›´å¥½åœ°äº†è§£ç¨‹åºçš„è¿è¡ŒçŠ¶æ€å’Œæ›´è¯¦å°½åœ°è¿›è¡Œè°ƒè¯•ã€‚æ›´å…·ä½“çš„å«ä¹‰å’Œè¡Œä¸ºå¯èƒ½ä¼šä¾æ®å…·ä½“çš„ç¨‹åºè€Œæœ‰æ‰€å·®å¼‚ã€‚
```

| Command         | Description                                                                                                                           |
|-----------------|---------------------------------------------------------------------------------------------------------------------------------------|
| `cargo new`     | Creates a new project in the current directory with a default structure.                                                              |
| `cargo check`   | Analyzes the current project and reports errors without compiling any files.                                                          |
| `cargo build`   | Compiles the current project, generating an executable or library in the `target` directory.                                          |
| `cargo run`     | Compiles and runs the file `src/main.rs`.                                                                                             |
| `cargo clean`   | Removes the `target` directory and all its subdirectories and files from the current project.                                         |
| `cargo update`  | Updates all dependencies listed in the `Cargo.lock` file of the current project.                                                      |
| `cargo test`    | Runs all tests in the project to ensure code correctness and stability.                                                               |
| `cargo doc`     | Generates documentation for the project based on code comments and information in the `Cargo.toml` file.                              |
| `cargo publish` | Publishes the current project to `crates.io`, making it available for other developers.                                               |
| `cargo install` | Installs specified Rust tools or libraries, making them globally available.                                                           |
| `cargo --list`  | Lists all available `cargo` subcommands along with brief descriptions, helping developers quickly understand the features of `cargo`. |
| `--verbose`     | Makes the program output more runtime information, aiding in debugging and understanding the program's operational state.             |

| å‘½ä»¤              | è¯´æ˜Ž                                              |
|-----------------|-------------------------------------------------|
| `cargo new`     | åœ¨å½“å‰ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªé¡¹ç›®                                    |
| `cargo check`   | åˆ†æžå½“å‰é¡¹ç›®å¹¶æŠ¥å‘Šé¡¹ç›®ä¸­çš„é”™è¯¯ï¼Œä½†ä¸ä¼šç¼–è¯‘ä»»ä½•é¡¹ç›®æ–‡ä»¶                     |
| `cargo build`   | ç¼–è¯‘å½“å‰é¡¹ç›®ï¼Œç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶æˆ–åº“ï¼Œè¾“å‡ºåˆ° `target` ç›®å½•                |
| `cargo run`     | ç¼–è¯‘å¹¶è¿è¡Œæ–‡ä»¶ Â `src/main. rs`                         |
| `cargo clean`   | ç§»é™¤å½“å‰é¡¹ç›®ä¸‹çš„ Â `target`Â  ç›®å½•åŠç›®å½•ä¸­çš„æ‰€æœ‰å­ç›®å½•å’Œæ–‡ä»¶             |
| `cargo update`  | æ›´æ–°å½“å‰é¡¹ç›®ä¸­çš„ Â `Cargo. lock`Â  æ–‡ä»¶åˆ—å‡ºçš„æ‰€æœ‰ä¾èµ–              |
| `cargo test`    | è¿è¡Œé¡¹ç›®ä¸­çš„æ‰€æœ‰æµ‹è¯•                                      |
| `cargo doc`     | ç”Ÿæˆé¡¹ç›®çš„æ–‡æ¡£ï¼ŒåŸºäºŽä»£ç æ³¨é‡Šå’Œ `Cargo.toml` æ–‡ä»¶ä¸­çš„ä¿¡æ¯             |
| `cargo publish` | å°†å½“å‰é¡¹ç›®å‘å¸ƒåˆ° `crates.io`ï¼Œä½¿å…¶å¯ä¾›å…¶ä»–å¼€å‘è€…ä½¿ç”¨                |
| `cargo install` | å®‰è£…æŒ‡å®šçš„ Rust å·¥å…·æˆ–åº“ï¼Œä½¿å…¶åœ¨å…¨å±€å¯ç”¨                         |
| `cargo --list`  | åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„ `cargo` å­å‘½ä»¤åŠå…¶ç®€è¦è¯´æ˜Žï¼Œå¸®åŠ©å¼€å‘è€…å¿«é€Ÿäº†è§£ `cargo` çš„åŠŸèƒ½ |
| `--verbose`     | `ä½¿ç¨‹åºè¾“å‡ºæ›´å¤šçš„è¿è¡Œæ—¶ä¿¡æ¯ï¼Œä¾¿äºŽè°ƒè¯•å’Œäº†è§£ç¨‹åºçš„è¿è¡ŒçŠ¶æ€`                  |

### `Cargo.toml` ðŸ“œ

`Cargo.toml`Â is a configuration file for managing your projectâ€™s metadata and dependencies.

`Cargo.toml` æ˜¯ç”¨äºŽç®¡ç†é¡¹ç›®å…ƒæ•°æ®å’Œä¾èµ–å…³ç³»çš„é…ç½®æ–‡ä»¶ã€‚

The `TOML` file format is, like JavaScript Object Notation (`JSON`) or YAML Ainâ€™t Markup Language (`YAML`).
`TOML` æ–‡ä»¶æ ¼å¼ä¸Ž JavaScript å¯¹è±¡è¡¨ç¤ºæ³• (`JSON`) æˆ– YAML éžæ ‡è®°è¯­è¨€ (`YAML`) ä¸€æ ·ã€‚

By specifying different version constraints in this file, developers can control the versions of the libraries their project depends on. This is crucial for ensuring the stability and compatibility of the project.
åœ¨è¯¥æ–‡ä»¶ä¸­æŒ‡å®šä¸åŒçš„ç‰ˆæœ¬çº¦æŸï¼Œå¼€å‘è€…å¯ä»¥æŽ§åˆ¶é¡¹ç›®æ‰€ä¾èµ–çš„åº“çš„ç‰ˆæœ¬ã€‚è¿™å¯¹äºŽç¡®ä¿é¡¹ç›®çš„ç¨³å®šæ€§å’Œå…¼å®¹æ€§è‡³å…³é‡è¦ã€‚

| Cargo.toml Line           | Meaning                                                   |
|---------------------------|-----------------------------------------------------------|
| `image = "=0.10.0"`       | Use only the exact version 0.10.0                         |
| `image = ">=1.0.5"`       | Use version 1.0.5 or higher (including 2.9, if available) |
| `image = ">1.0.5 <1.1.9"` | Use a version greater than 1.0.5 but less than 1.1.9      |
| `image = "<=2.7.10"`      | Use version 2.7.10 or any earlier version                 |

| Cargo. toml è¡Œ             | å«ä¹‰                             |
|---------------------------|--------------------------------|
| `image = "=0.10.0"`       | ä»…ä½¿ç”¨ç¡®åˆ‡çš„ç‰ˆæœ¬ 0.10.0                |
| `image = ">=1.0.5"`       | ä½¿ç”¨ 1.0.5 æˆ–æ›´é«˜ç‰ˆæœ¬ï¼ˆç”šè‡³ 2.9ï¼Œå¦‚æžœå…¶å¯ç”¨çš„è¯ï¼‰ |
| `image = ">1.0.5 <1.1.9"` | ä½¿ç”¨é«˜äºŽ 1.0.5 ä½†ä½ŽäºŽ 1.1.9 çš„ç‰ˆæœ¬       |
| `image = "<=2.7.10"`      | ä½¿ç”¨ 2.7.10 æˆ–æ›´æ—©çš„ä»»ä½•ç‰ˆæœ¬             |

### `Cargo.lock` ðŸ”’

When building a project for the first time, Cargo outputs a `Cargo.lock` file to record the exact version of each crate it uses. Subsequent builds will refer to this file and continue using the same versions. Cargo will only upgrade to newer versions when you explicitly request it, either by manually increasing the version number in the `Cargo.toml` file or by runningÂ `cargo update`.

å½“ç¬¬ä¸€æ¬¡æž„å»ºé¡¹ç›®æ—¶ï¼ŒCargo ä¼šè¾“å‡ºä¸€ä¸ª `Cargo.lock` æ–‡ä»¶ï¼Œä»¥è®°å½•å®ƒä½¿ç”¨çš„æ¯ä¸ª crate çš„ç¡®åˆ‡ç‰ˆæœ¬ã€‚ä»¥åŽçš„æž„å»ºéƒ½å°†å‚è€ƒæ­¤æ–‡ä»¶å¹¶ç»§ç»­ä½¿ç”¨ç›¸åŒçš„ç‰ˆæœ¬ã€‚ä»…å½“ä½ è¦æ±‚ Cargo å‡çº§æ—¶å®ƒæ‰ä¼šå‡çº§åˆ°æ›´æ–°ç‰ˆæœ¬ï¼Œæ–¹æ³•æ˜¯æ‰‹åŠ¨å¢žåŠ  `Cargo.toml` æ–‡ä»¶ä¸­çš„ç‰ˆæœ¬å·æˆ–è¿è¡Œ Â `cargo update`ã€‚

The `Cargo.lock` file is automatically generated and typically doesn't need manual editing. However, if your project is an executable, you should commit the `Cargo.lock` file to version control. This ensures that everyone building the project always gets the same versions. The version history of the `Cargo.lock` file will record these dependency updates.

`Cargo.lock` æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œé€šå¸¸ä¸ç”¨æ‰‹åŠ¨ç¼–è¾‘ã€‚ä¸è¿‡ï¼Œå¦‚æžœæ­¤é¡¹ç›®æ˜¯å¯æ‰§è¡Œæ–‡ä»¶ï¼Œé‚£ä½ å°±åº”è¯¥å°† `Cargo.lock` æäº¤åˆ°ç‰ˆæœ¬æŽ§åˆ¶ã€‚è¿™æ ·ï¼Œæž„å»ºé¡¹ç›®çš„æ¯ä¸ªäººæ€»æ˜¯ä¼šèŽ·å¾—ç›¸åŒçš„ç‰ˆæœ¬ã€‚`Cargo.lock`æ–‡ä»¶çš„ç‰ˆæœ¬åŽ†å²ä¸­ä¼šè®°å½•è¿™äº›ä¾èµ–é¡¹æ›´æ–°ã€‚

## 6. Optimization ä¼˜åŒ– ðŸš€

In Rust, optimization can significantly improve a program's performance. Below are some common optimization techniques, including compilation configuration, link-time optimization, panic handling, and compile-time optimization.

åœ¨ Rust ä¸­ï¼Œä¼˜åŒ–å¯ä»¥æ˜¾è‘—æé«˜ç¨‹åºçš„æ€§èƒ½ã€‚ä»¥ä¸‹å°†ä»‹ç»å‡ ç§å¸¸ç”¨çš„ä¼˜åŒ–æŠ€å·§ï¼ŒåŒ…æ‹¬ç¼–è¯‘é…ç½®ã€é“¾æŽ¥æ—¶ä¼˜åŒ–ã€panic å¤„ç†ä»¥åŠç¼–è¯‘æ—¶é—´ä¼˜åŒ–ã€‚

### Compilation Configuration ç¼–è¯‘é…ç½® âš™

Debug Mode (`cargo build`):

- Configuration Section: `[profile.dev]`
- Advantages: Fast compilation, suitable for debugging
- Disadvantages: Slower runtime, no optimization

Debug æ¨¡å¼ (`cargo build`)ï¼š

- é…ç½®åŒºæ®µ: `[profile.dev]`
- ä¼˜ç‚¹: ç¼–è¯‘é€Ÿåº¦å¿«ï¼Œé€‚åˆè°ƒè¯•
- ç¼ºç‚¹: è¿è¡Œé€Ÿåº¦è¾ƒæ…¢ï¼Œä¸è¿›è¡Œä¼˜åŒ–

Release Mode (`cargo build --release`):

- Configuration Section: `[profile.release]`
- Advantages: Faster runtime, various optimizations
- Disadvantages: Longer compilation time, larger binary size

Release æ¨¡å¼ (`cargo build --release`)ï¼š

- é…ç½®åŒºæ®µ: `[profile.release]`
- ä¼˜ç‚¹: è¿è¡Œé€Ÿåº¦å¿«ï¼Œè¿›è¡Œå¤šç§ä¼˜åŒ–
- ç¼ºç‚¹: ç¼–è¯‘æ—¶é—´é•¿ï¼Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶å¯èƒ½è¾ƒå¤§

It is common practice to use debug mode during development and release mode when deploying.
åœ¨å¼€å‘è¿‡ç¨‹ä¸­ä½¿ç”¨ debug æ¨¡å¼ï¼Œè€Œåœ¨å‘å¸ƒæ—¶ä½¿ç”¨ release æ¨¡å¼æ˜¯å¸¸è§åšæ³•ã€‚

By default, Rust builds in debug mode. If you run `cargo build`, `cargo run`, or `rustc` without any additional options, it will generate a debug build. Debug builds are useful for debugging but are not optimized.
é»˜è®¤çš„æ˜¯ debug æž„å»ºâ€”â€” å¦‚æžœä½ è¿è¡Œ Â `cargo build`ï¼Œ`cargo run`ï¼Œ`rustc`ï¼Œå¹¶ä¸”ä¸å¸¦å…¶ä»–é€‰é¡¹ï¼Œå°±ä¼šç”Ÿæˆ debug æž„å»ºã€‚ debug æž„å»ºå¯¹è°ƒè¯•å¾ˆæœ‰ç”¨ï¼Œä½†æ˜¯å¹¶ä¸ä¼˜åŒ–ã€‚

When you compile your Rust program in release mode, the compiler performs a series of optimizations such as inlining, loop unrolling, dead code elimination, and constant folding. These optimizations make your program run faster, but they also increase compilation time and may result in larger binary files.
åœ¨ Release æ¨¡å¼ä¸‹ç¼–è¯‘ä½ çš„ Rust ç¨‹åºæ—¶ï¼Œç¼–è¯‘å™¨ä¼šè¿›è¡Œä¸€ç³»åˆ—çš„ä¼˜åŒ–ï¼Œä¾‹å¦‚å†…è”ï¼Œå¾ªçŽ¯å±•å¼€ï¼Œæ­»ä»£ç åˆ é™¤ï¼Œå¸¸é‡æŠ˜å ç­‰ã€‚è¿™äº›ä¼˜åŒ–ä¼šä½¿ä½ çš„ç¨‹åºè¿è¡Œå¾—æ›´å¿«ã€‚ç„¶è€Œï¼Œè¿™äº›ä¼˜åŒ–ä¹Ÿä¼šä½¿ä½ çš„ç¨‹åºçš„ç¼–è¯‘æ—¶é—´æ›´é•¿ï¼Œå¹¶å¯èƒ½ä½¿ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶æ›´å¤§ã€‚

```rust
// src/main.rs
fn fibonacci(n: u64) -> u64 {
    if n <= 1 {
        return n;
    }
    fibonacci(n - 1) + fibonacci(n - 2)
}

fn main() {
    let n = 40;
    println!("Fibonacci({}) = {}", n, fibonacci(n));
}
```

```shell
# Debugæ¨¡å¼
$ cargo run
   Compiling fib v0.1.0 (/path/to/fib)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target/debug/fib`
Fibonacci(40) = 102334155
# è¿è¡Œæ—¶é—´ï¼šçº¦5ç§’

# Releaseæ¨¡å¼
$ cargo run --release
   Compiling fib v0.1.0 (/path/to/fib)
    Finished release [optimized] target(s) in 0.72s
     Running `target/release/fib`
Fibonacci(40) = 102334155
# è¿è¡Œæ—¶é—´ï¼šçº¦0.05ç§’
```

- `[unoptimized + debuginfo]` indicates that a debug build was generated. The compiled code will be placed in the `target/debug/` directory. `cargo run` will run the program built in debug mode.
- `[optimized]` indicates that a release build was generated. The compiled code will be placed in the `target/release/` directory. `cargo run --release` will run the program built in release mode.

- `[unoptimized + debuginfo]`Â  è¡¨ç¤ºç”Ÿæˆçš„æ˜¯ debug æž„å»ºã€‚ç¼–è¯‘åŽçš„ä»£ç ä¼šæ”¾åœ¨ Â `target/debug/`Â  ç›®å½•ä¸­ã€‚Â `cargo run`Â  ä¼šè¿è¡Œ debug æž„å»ºçš„ç¨‹åºã€‚
- `[optimized]`Â  è¡¨ç¤ºç”Ÿæˆçš„æ˜¯ release æž„å»ºã€‚ç¼–è¯‘å¥½çš„ä»£ç ä¼šæ”¾åœ¨ Â `target/release/`Â  ç›®å½•ä¸­ã€‚Â `cargo run --release`Â  ä¼šè¿è¡Œ release æž„å»ºã€‚

### Link-Time Optimization é“¾æŽ¥æ—¶ä¼˜åŒ– ðŸ”¨

Link-Time Optimization (LTO) is a whole-program optimization technique that can improve runtime performance by 10%-20% or more at the cost of increased build time. For a single Rust program, it's usually worthwhile to trade off compilation time for runtime performance. Enabling LTO slightly increases compilation time but further reduces runtime.
é“¾æŽ¥æ—¶ä¼˜åŒ– (Link-time optimization, LTO) æ˜¯ä¸€ç§é€‚ç”¨äºŽæ•´ä¸ªç¨‹åºçš„ä¼˜åŒ–æŠ€æœ¯ï¼Œä»¥å¢žåŠ æž„å»ºæ—¶é—´ä¸ºä»£ä»·ï¼Œå¯ä»¥æé«˜ 10%-20% æˆ–æ›´å¤šçš„è¿è¡Œæ—¶æ€§èƒ½ï¼Œå¯¹äºŽå•ä¸ª Rust ç¨‹åºï¼Œé€šå¸¸ç”¨ç¼–è¯‘æ—¶é—´æ¢å–è¿è¡Œæ€§èƒ½æ˜¯å€¼å¾—çš„ï¼ˆå¯ç”¨ LTO åŽï¼Œç¼–è¯‘æ—¶é—´ç•¥æœ‰å¢žåŠ ï¼Œä½†è¿è¡Œæ—¶é—´è¿›ä¸€æ­¥å‡å°‘ï¼‰ã€‚

The simplest way to enable LTO is to add the following lines to `Cargo.toml` and then perform a release build.
å¯ç”¨ LTO æœ€ç®€å•çš„æ–¹æ³•æ˜¯ï¼Œå‘ Â `Cargo.toml`Â  ä¸­æ·»åŠ ä¸‹åˆ—è¡Œï¼Œç„¶åŽè¿›è¡Œ release æž„å»ºã€‚

```toml
[profile.release]
lto = true
```

Alternatively, using `lto = "thin"` in `Cargo.toml` enables Thin LTO, a less aggressive form of LTO that is usually as effective as full LTO but doesnâ€™t significantly increase build time.
å¦å¤–ï¼Œåœ¨ Â `Cargo.toml`Â  ä¸­ä½¿ç”¨ Â `lto = "thin"`Â  åˆ™ä¼šå¯ç”¨ â€œè½»é‡çº§â€(thin) LTOâ€”â€”ä¸€ç§ä¸é‚£ä¹ˆæ¿€è¿›çš„ LTO å½¢å¼ï¼Œé€šå¸¸ä¸Žé‡é‡çº§ LTO ä¸€æ ·æœ‰æ•ˆï¼Œä½†ä¸ä¼šè¿‡å¤šå¢žåŠ æž„å»ºæ—¶é—´ã€‚

```toml
[profile.release]
lto = "thin"
```

```
cargo run --release
```

### Panic! with Abort panic! æ—¶ abort ðŸ”—

If you don't need to catch or unwind from a panic, you can configure the program to abort on panic. This can reduce the binary size and slightly improve performance:
å¦‚æžœä¸éœ€è¦æ•èŽ·æˆ–å±•å¼€ panicï¼Œå¯ä»¥é…ç½®åœ¨ panic æ—¶ç›´æŽ¥ä¸­æ­¢ç¨‹åºï¼Œè¿™æ ·å¯ä»¥å‡å°äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°å¹¶ç•¥å¾®æå‡æ€§èƒ½ï¼š

```toml
[profile.release]
panic = "abort"
```

```
# ä¼˜åŒ–å‰
$ ls -lh target/release/fib
-rwxr-xr-x 2 user user 3.8M Aug 13 10:00 target/release/fib

# ä¼˜åŒ–åŽ
$ cargo build --release
$ ls -lh target/release/fib
-rwxr-xr-x 2 user user 3.6M Aug 13 10:05 target/release/fib
```

### Faster Linker æ›´å¿«çš„é“¾æŽ¥å™¨ ðŸš€

It is recommended to use [lld](https://lld.llvm.org/), which supports ELF, PE/COFF, Mach-O, wasm, and more.
è¿™é‡ŒæŽ¨è [lld](https://lld.llvm.org/)ï¼Œå®ƒæ”¯æŒ ELFï¼ŒPE/COFFï¼ŒMach-Oï¼Œwasm ç­‰ç­‰ã€‚

To specify using `lld` via the command line, you can prepend your build command with `RUSTFLAGS="-C link-arg=-fuse-ld=lld"`.
é€šè¿‡å‘½ä»¤è¡ŒæŒ‡å®šä½¿ç”¨ lldï¼Œä½ å¯ä»¥åœ¨ä½ çš„æž„å»ºå‘½ä»¤å‰åŠ ä¸Š `RUSTFLAGS="-C link-arg=-fuse-ld=lld"`

Alternatively, you can configure it in `config.toml`:
æˆ–åœ¨`config.toml`ä¸­é…ç½®:

```toml
[build]
rustflags = ["-C", "link-arg=-fuse-ld=lld"]
```

```
# ä½¿ç”¨é»˜è®¤é“¾æŽ¥å™¨
$ time cargo build --release
    Finished release [optimized] target(s) in 25.32s

real    0m25.320s
user    0m24.156s
sys     0m1.164s

# ä½¿ç”¨lld
$ RUSTFLAGS="-C link-arg=-fuse-ld=lld" time cargo build --release
    Finished release [optimized] target(s) in 20.15s

real    0m20.150s
user    0m19.228s
sys     0m0.922s
```

### Incremental Compilation å¢žé‡ç¼–è¯‘ âž•

The Rust compiler supports incremental compilation, which avoids redundant work during recompilation. It can significantly speed up compilation, but sometimes it may result in slower-running executables. Therefore, it is enabled by default only for debug builds. If you want to enable it for release builds as well, add the following to `Cargo.toml`:
Rust ç¼–è¯‘å™¨æ”¯æŒå¢žé‡ç¼–è¯‘ï¼Œé¿å…åœ¨é‡ç¼–è¯‘çš„æ—¶å€™åšé‡å¤çš„å·¥ä½œã€‚å®ƒå¯ä»¥å¤§å¤§æå‡ç¼–è¯‘é€Ÿåº¦ï¼Œä½†æœ‰æ—¶ä¼šè®©ç”Ÿæˆçš„å¯æ‰§è¡Œç¨‹åºè¿è¡Œçš„æ…¢ä¸€äº›ã€‚å› æ­¤ï¼Œå®ƒåªé»˜è®¤ä¸ºè°ƒè¯•æž„å»ºå¯ç”¨ã€‚å¦‚æžœä½ ä¹Ÿæƒ³ä¸ºå‘å¸ƒæž„å»ºå¯ç”¨ï¼ŒæŠŠè¿™äº›åŠ åˆ° `Cargo.toml`ï¼š

```toml
[profile.release]
incremental = true
```

```
$ touch src/main.rs
$ time cargo build --release
   Compiling project v0.1.0 (/path/to/project)
    Finished release [optimized] target(s) in 1m 45s

real    1m45.150s
user    1m43.228s
sys     0m1.922s


$ touch src/main.rs
$ time cargo build --release
   Compiling project v0.1.0 (/path/to/project)
    Finished release [optimized] target(s) in 0m 25s

real    0m25.120s
user    0m24.156s
sys     0m0.964s
```
