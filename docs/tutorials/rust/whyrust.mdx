---
sidebar_label: Why Rust?
title: Why Rust?
sidebar_position: 1
---

## 1. Overview åˆå°è±¡ ğŸ§

A language empowering everyone to build reliable and efficient software.

ä¸€é—¨èµ‹äºˆæ¯ä¸ªäººæ„å»ºå¯é ä¸”é«˜æ•ˆè½¯ä»¶èƒ½åŠ›çš„è¯­è¨€ã€‚

Rust is one of the most widely used languages in blockchain systems and many popular blockchains including <u>Solana, Polkadot, Aptos, and Sui</u> are built with Rust. Rust frameworks such as <u>Foundry</u> are also highly preferred by developers of established chainsÂ including Ethereum.

Rust æ˜¯åŒºå—é“¾ç³»ç»Ÿä¸­æœ€å¹¿æ³›ä½¿ç”¨çš„è¯­è¨€ä¹‹ä¸€ï¼Œè®¸å¤šæµè¡Œçš„åŒºå—é“¾åŒ…æ‹¬ <u>Solanaã€Polkadotã€Aptos å’Œ Sui</u> éƒ½æ˜¯ç”¨ Rust æ„å»ºçš„ã€‚è¯¸å¦‚ <u>Foundry</u> ç­‰ Rust æ¡†æ¶ä¹Ÿå—åˆ°åŒ…æ‹¬ä»¥å¤ªåŠåœ¨å†…çš„åŒºå—é“¾å¼€å‘äººå‘˜çš„é«˜åº¦é’çã€‚

The use of Rust is growing rapidly among blockchain projects, with more and more developers and teams recognizing the advantages of its performance and safety. In the coming years, we will see an exponential increase in this trend.

Rust çš„ä½¿ç”¨åœ¨åŒºå—é“¾é¡¹ç›®ä¸­æ­£åœ¨è¿…é€Ÿå¢é•¿ï¼Œè¶Šæ¥è¶Šå¤šçš„å¼€å‘è€…å’Œå›¢é˜Ÿå¼€å§‹è®¤è¯†åˆ°å…¶æ€§èƒ½å’Œå®‰å…¨æ€§å¸¦æ¥çš„ä¼˜åŠ¿ã€‚åœ¨æœªæ¥å‡ å¹´ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°è¿™ä¸€è¶‹åŠ¿çš„æŒ‡æ•°çº§å¢é•¿ã€‚

> [GitHub - rust-in-blockchain/awesome-blockchain-rust](https://github.com/rust-in-blockchain/awesome-blockchain-rust)

Rust is a modern programming language that has been gaining a reputation for its focus on safety and performance, making it worth learning for all developers!

Rust æ˜¯ä¸€ç§ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼Œä»¥å…¶å¯¹å®‰å…¨æ€§å’Œæ€§èƒ½çš„å…³æ³¨è€Œå£°åè¿œæ‰¬ï¼Œå€¼å¾—æˆ‘ä»¬æ‰€æœ‰å¼€å‘è€…å­¦ä¹ ï¼

## 2. Features ç‰¹ç‚¹ âœ¨

### Safety å®‰å…¨ ğŸ›¡
Rust offers memory safety without the need for a garbage collector through its innovative ownership model.

Rust é€šè¿‡å…¶åˆ›æ–°çš„æ‰€æœ‰æƒæ¨¡å‹ç¡®ä¿å†…å­˜å®‰å…¨ï¼Œè€Œæ— éœ€åƒåœ¾æ”¶é›†å™¨ã€‚

Memory safety means that the language prevents bugs that lead to crashes or security vulnerabilities due to mishandled memory.

å†…å­˜å®‰å…¨æ„å‘³ç€è¯¥è¯­è¨€å¯ä»¥é˜²æ­¢ç”±äºå†…å­˜å¤„ç†ä¸å½“è€Œå¯¼è‡´å´©æºƒæˆ–å®‰å…¨æ¼æ´çš„é”™è¯¯ã€‚

Rust's ownership model ensures that variables are deallocated when they go out of scope, preventing memory leaks and dangling references.

Rust çš„æ‰€æœ‰æƒæ¨¡å‹ç¡®ä¿å˜é‡åœ¨è¶…å‡ºä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼å’Œæ‚¬æŒ‚å¼•ç”¨ã€‚

Additionally, Rust's borrow checker enforces strict rules around mutable and immutable references, preventing data races and other common concurrency bugs.

æ­¤å¤–ï¼ŒRust çš„å€Ÿç”¨æ£€æŸ¥å™¨å¼ºåˆ¶æ‰§è¡Œå¯¹å¯å˜å’Œä¸å¯å˜å¼•ç”¨çš„ä¸¥æ ¼è§„åˆ™ï¼Œé˜²æ­¢æ•°æ®ç«äº‰å’Œå…¶ä»–å¸¸è§çš„å¹¶å‘é”™è¯¯ã€‚

### High Performance é«˜æ€§èƒ½ ğŸš€

Rust offers the speed of a compiled language and the efficiency of manual memory management without a garbage collector, making it an ideal candidate for performance-critical domains. Rustâ€™s unique â€œzero-cost abstractionsâ€ allow us to write code that is both high-performance and safe without experiencing additional runtime overhead.

Rust æä¾›äº†ç¼–è¯‘å‹è¯­è¨€çš„é€Ÿåº¦å’Œæ— éœ€åƒåœ¾æ”¶é›†å™¨çš„æ‰‹åŠ¨å†…å­˜ç®¡ç†æ•ˆç‡ï¼Œä½¿å…¶æˆä¸ºæ€§èƒ½å…³é”®é¢†åŸŸçš„ç†æƒ³é€‰æ‹©ã€‚Rust ç‹¬ç‰¹çš„â€œé›¶æˆæœ¬æŠ½è±¡â€ä½¿æˆ‘ä»¬èƒ½å¤Ÿç¼–å†™é«˜æ€§èƒ½ä¸”å®‰å…¨çš„ä»£ç ï¼Œè€Œæ— éœ€ç»å†é¢å¤–çš„è¿è¡Œæ—¶å¼€é”€ã€‚

:::info

Garbage collectionÂ involves the automated process of reclaiming memory that the runtime is no longer using. In simplerÂ terms, it serves as a means to eliminate unused objects. The purpose of garbage collection is to prevent a program from exceeding its allocated memory capacity or reachingÂ a state where it can no longer operate properly. Additionally, it relieves developers from the manual burden of managing a programâ€™s memory, thereby reducing the potential forÂ memory-related errors.

åƒåœ¾æ”¶é›†æ¶‰åŠå›æ”¶è¿è¡Œæ—¶ä¸å†ä½¿ç”¨çš„å†…å­˜çš„è‡ªåŠ¨åŒ–è¿‡ç¨‹ã€‚ç®€å•æ¥è¯´ï¼Œå®ƒæ˜¯æ¶ˆé™¤æœªä½¿ç”¨å¯¹è±¡çš„ä¸€ç§æ‰‹æ®µã€‚åƒåœ¾æ”¶é›†çš„ç›®çš„æ˜¯é˜²æ­¢ç¨‹åºè¶…å‡ºå…¶åˆ†é…çš„å†…å­˜å®¹é‡æˆ–è¾¾åˆ°æ— æ³•å†æ­£å¸¸è¿è¡Œçš„çŠ¶æ€ã€‚æ­¤å¤–ï¼Œå®ƒè¿˜å‡è½»äº†å¼€å‘äººå‘˜æ‰‹åŠ¨ç®¡ç†ç¨‹åºå†…å­˜çš„è´Ÿæ‹…ï¼Œä»è€Œå‡å°‘äº†å‡ºç°å†…å­˜ç›¸å…³é”™è¯¯çš„å¯èƒ½æ€§ã€‚

In contrast, Rust takes a distinct approach by forgoing the use of a garbage collector. Instead, it accomplishes these objectives through a sophisticated yet intricate type system. This methodology renders Rust exceptionally efficient; however, it also introduces a higher level of complexity to the learning and utilizationÂ of Rust.

ç›¸æ¯”ä¹‹ä¸‹ï¼ŒRust é‡‡ç”¨äº†ä¸€ç§ç‹¬ç‰¹çš„æ–¹æ³•ï¼Œæ”¾å¼ƒä½¿ç”¨åƒåœ¾æ”¶é›†å™¨ã€‚ç›¸åï¼Œå®ƒé€šè¿‡å¤æ‚è€Œå¤æ‚çš„ç±»å‹ç³»ç»Ÿæ¥å®ç°è¿™äº›ç›®æ ‡ã€‚è¿™ç§æ–¹æ³•ä½¿ Rust å¼‚å¸¸é«˜æ•ˆï¼›ç„¶è€Œï¼Œå®ƒä¹Ÿç»™ Rust çš„å­¦ä¹ å’Œä½¿ç”¨å¸¦æ¥äº†æ›´é«˜ç¨‹åº¦çš„å¤æ‚æ€§ã€‚

:::

### Fearless Concurrency å¹¶å‘ ğŸ¤
Rust aims to make concurrent programming accessible and safe. It offers abstractions like threads and asynchronous programming while enforcing thread safety through the type system.

Rust æ—¨åœ¨ä½¿å¹¶å‘ç¼–ç¨‹å˜å¾—å¯è®¿é—®å’Œå®‰å…¨ã€‚å®ƒæä¾›äº†è¯¸å¦‚çº¿ç¨‹å’Œå¼‚æ­¥ç¼–ç¨‹ä¹‹ç±»çš„æŠ½è±¡ï¼ŒåŒæ—¶é€šè¿‡ç±»å‹ç³»ç»Ÿå¼ºåˆ¶æ‰§è¡Œçº¿ç¨‹å®‰å…¨ã€‚

### Ecosystem ç”Ÿæ€ç³»ç»Ÿ ğŸŒ

Rust's ecosystem offers a treasure trove of libraries, tools, and frameworks.

Rust çš„ç”Ÿæ€ç³»ç»Ÿæä¾›äº†ä¸°å¯Œçš„åº“ã€å·¥å…·å’Œæ¡†æ¶ã€‚

The Cargo package manager simplifies dependency management, compilation, and building of Rust projects, fostering a vibrant ecosystem that continuously expands the language's applicability.

Cargo åŒ…ç®¡ç†å™¨ç®€åŒ–äº†ä¾èµ–é¡¹ç®¡ç†ã€ç¼–è¯‘å’Œæ„å»º Rust é¡¹ç›®çš„è¿‡ç¨‹ï¼ŒåŸ¹è‚²äº†ä¸€ä¸ªå……æ»¡æ´»åŠ›çš„ç”Ÿæ€ç³»ç»Ÿï¼Œä¸æ–­æ‰©å±•è¯­è¨€çš„é€‚ç”¨æ€§ã€‚

Furthermore, the integration with various languages through FFI (Foreign Function Interface) effectively bridges the gap between Rust's system-level efficiency and the user-friendly nature of high-level scripting languages.

æ­¤å¤–ï¼Œé€šè¿‡ FFIï¼ˆå¤–éƒ¨å‡½æ•°æ¥å£ï¼‰ä¸å„ç§è¯­è¨€çš„é›†æˆï¼Œæœ‰æ•ˆåœ°å¼¥åˆäº† Rust ç³»ç»Ÿçº§æ•ˆç‡ä¸é«˜çº§è„šæœ¬è¯­è¨€çš„æ˜“ç”¨æ€§ä¹‹é—´çš„é¸¿æ²Ÿã€‚

Rust, while still growing, has an active community that continuously develops and maintains libraries (crates) for a wide range of use cases. You can find all sorts of libraries on [`crates.io`](http://crates.io).

Rust ä»åœ¨ä¸æ–­å‘å±•å£®å¤§ï¼Œå…¶æ´»è·ƒçš„ç¤¾åŒºä¸æ–­å¼€å‘å’Œç»´æŠ¤é€‚ç”¨äºå„ç§ç”¨ä¾‹çš„åº“ã€‚ä½ å¯ä»¥åœ¨ `crates.io` ä¸Šæ‰¾åˆ°å„ç§å„æ ·çš„åº“ã€‚

### Open Source Community å¼€æºç¤¾åŒº ğŸ§‘â€ğŸ¤â€ğŸ§‘

Rust has a very friendly and vibrant open-source developer community. This community is known for its enthusiasm, inclusivity, and willingness to help.

Rust æ‹¥æœ‰ä¸€ä¸ªéå¸¸å‹å¥½å’Œå……æ»¡æ´»åŠ›çš„å¼€æºå¼€å‘è€…ç¤¾åŒºã€‚è¿™ä¸ªç¤¾åŒºä»¥å…¶çƒ­æƒ…ã€åŒ…å®¹å’Œä¹äºåŠ©äººè€Œé—»åã€‚

## 3. Hello World ğŸ§‘â€

### Creating a New Project æ–°å»ºé¡¹ç›® â•

`cargo new hello-rust`

### Project File Structure é¡¹ç›®æ–‡ä»¶ç»“æ„ ğŸ“

```
hello-rust/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ .gitignore
â””â”€â”€ src/
    â””â”€â”€ main.rs
```

- `Cargo.toml` is the core configuration file for Rust projects, used to define project metadata, dependencies, and build settings.

- `Cargo.toml` æ˜¯ Rust é¡¹ç›®çš„æ ¸å¿ƒé…ç½®æ–‡ä»¶ï¼Œç”¨äºå®šä¹‰é¡¹ç›®å…ƒæ•°æ®ã€ä¾èµ–å…³ç³»å’Œæ„å»ºè®¾ç½®ã€‚

- `.gitignore` file is used to specify which files and directories should be ignored by Git when tracking changes in a repository.

- `.gitignore` æ–‡ä»¶ç”¨äºæŒ‡å®šåœ¨ Git ç‰ˆæœ¬æ§åˆ¶ä¸­åº”è¢«å¿½ç•¥çš„æ–‡ä»¶å’Œç›®å½•ã€‚

- `src/main.rs` is where weâ€™ll write our application code.

- `src/main.rs` æ˜¯æˆ‘ä»¬è¦å†™åº”ç”¨ç¨‹åºä»£ç çš„åœ°æ–¹ã€‚

### Writing the Program ç¼–å†™ç¨‹åº âœ

```rust
fn main() {
	println!("Hello World");
}
```

In Rust, every executable program must include a function namedÂ `main`Â as the entry point.

åœ¨ Rust ä¸­ï¼Œæ¯ä¸ªå¯æ‰§è¡Œç¨‹åºéƒ½å¿…é¡»åŒ…å«ä¸€ä¸ªåä¸º Â `main`Â  çš„å‡½æ•°ä½œä¸ºå…¥å£ç‚¹ã€‚

`println!("Hello World");`

This is a macro call used to output text to the standard output.

è¿™æ˜¯ä¸€ä¸ªå®è°ƒç”¨ï¼Œç”¨äºå°†æ–‡æœ¬è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºã€‚

`println!`Â is one of the macros provided by Rust's standard library, which prints a line of text to the console and automatically adds a newline at the end. Unlike other languages where placeholders likeÂ `%s`Â orÂ `%d`Â are used,Â `println`Â in Rust usesÂ `{}`. This is because Rust does a lot of work under the hood to automatically recognize the type of the output data.

`println!`Â  æ˜¯ Rust æ ‡å‡†åº“æä¾›çš„å®ä¹‹ä¸€ï¼Œå®ƒåœ¨æ§åˆ¶å°æ‰“å°ä¸€è¡Œæ–‡æœ¬ï¼Œå¹¶è‡ªåŠ¨åœ¨æœ«å°¾æ·»åŠ æ¢è¡Œç¬¦ã€‚å¯¹äº Â `println`Â  æ¥è¯´ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨å…¶å®ƒè¯­è¨€æƒ¯ç”¨çš„ Â `%s`ã€`%d`Â  æ¥åšè¾“å‡ºå ä½ç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨ Â `{}`ï¼Œå› ä¸º Rust åœ¨åº•å±‚å¸®æˆ‘ä»¬åšäº†å¤§é‡å·¥ä½œï¼Œä¼šè‡ªåŠ¨è¯†åˆ«è¾“å‡ºæ•°æ®çš„ç±»å‹ã€‚

### Running Code è¿è¡Œä»£ç  â–¶ï¸

`cargo run`

## 4. Number Guessing Game çŒœæ•°æ¸¸æˆ ğŸ”¢

In this game, the computer randomly generates a number, and the player needs to guess what that number is. After each guess, the program will inform the player whether their guess is too high, too low, or correct. Through this process, the player can gradually narrow down the range until they find the correct number.

åœ¨è¿™ä¸ªæ¸¸æˆä¸­ï¼Œè®¡ç®—æœºä¼šéšæœºç”Ÿæˆä¸€ä¸ªæ•°å­—ï¼Œç„¶åç©å®¶éœ€è¦çŒœæµ‹è¿™ä¸ªæ•°å­—ã€‚æ¯æ¬¡çŒœæµ‹åï¼Œç¨‹åºä¼šå‘Šè¯‰ç©å®¶çŒœçš„æ•°å­—æ˜¯å¤ªå¤§ã€å¤ªå°è¿˜æ˜¯æ­£ç¡®ã€‚é€šè¿‡è¿™ä¸ªè¿‡ç¨‹ï¼Œç©å®¶å¯ä»¥é€æ­¥ç¼©å°èŒƒå›´ï¼Œç›´åˆ°æ‰¾åˆ°æ­£ç¡®çš„æ•°å­—ã€‚

### Input/Output ğŸ“¥/ğŸ“¤

Enter a number and it will be displayed.

è¾“å…¥ä¸€ä¸ªæ•°å¹¶è¾“å‡ºã€‚

```rust
use std::io;

fn main() {
    println!("Please input your guessï¼š");
    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("You guessed: {}", guess);
}
```

`use std::io;`

This line imports the input/output module from Rust's standard library, allowing us to use input/output related functionalities.

è¿™è¡Œä»£ç å¯¼å…¥äº† Rust æ ‡å‡†åº“ä¸­çš„ input/output æ¨¡å—ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨è¾“å…¥è¾“å‡ºç›¸å…³çš„åŠŸèƒ½ã€‚

`fn main()`

Defines the main function of the program, where the execution begins.

å®šä¹‰äº†ç¨‹åºçš„ä¸»å‡½æ•°ï¼Œç¨‹åºçš„æ‰§è¡Œä»è¿™é‡Œå¼€å§‹ã€‚

`println!("Please input your guessï¼š");`

Uses theÂ `println!`Â macro to print a prompt message to the console, asking the user to input their guess.

ä½¿ç”¨ Â `println!`Â  å®åœ¨æ§åˆ¶å°æ‰“å°ä¸€æ¡æç¤ºä¿¡æ¯ï¼Œè¦æ±‚ç”¨æˆ·è¾“å…¥çŒœæµ‹ã€‚

`let mut guess = String::new();`

Creates a mutableÂ `String`Â type variableÂ `guess`Â to store user input. TheÂ `mut`Â keyword indicates that this variable is mutable.

åˆ›å»ºä¸€ä¸ªå¯å˜çš„ Â `String`Â  ç±»å‹å˜é‡ Â `guess`ï¼Œç”¨äºå­˜å‚¨ç”¨æˆ·è¾“å…¥ã€‚`mut`Â  å…³é”®å­—è¡¨ç¤ºè¿™ä¸ªå˜é‡æ˜¯å¯å˜çš„ã€‚

`io::stdin()`

Calls theÂ `stdin`Â function from theÂ `io`Â module, returning a handle to the standard input.

è°ƒç”¨ Â `io`Â  æ¨¡å—çš„ Â `stdin`Â  å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ ‡å‡†è¾“å…¥çš„å¥æŸ„ã€‚

`.read_line(&mut guess)`

Calls theÂ `read_line`Â method on the standard input handle to read a line of text from user input.Â `&mut guess`Â is a mutable reference, indicating that the user input will be stored in theÂ `guess`Â variable.

åœ¨æ ‡å‡†è¾“å…¥å¥æŸ„ä¸Šè°ƒç”¨ Â `read_line`Â  æ–¹æ³•ï¼Œè¯»å–ç”¨æˆ·è¾“å…¥çš„ä¸€è¡Œæ–‡æœ¬ã€‚`&mut guess`Â  æ˜¯ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¡¨ç¤ºå°†ç”¨æˆ·è¾“å…¥å­˜å‚¨åˆ° Â `guess`Â  å˜é‡ä¸­ã€‚

`.expect("Failed to read line");`

TheÂ `read_line`Â method returns aÂ `Result`Â type, andÂ `expect`Â is used to handle potential errors. If reading fails, the program will terminate and display the specified error message.

`read_line`Â  æ–¹æ³•è¿”å›ä¸€ä¸ª Â `Result`Â  ç±»å‹ï¼Œ`expect`Â  ç”¨äºå¤„ç†å¯èƒ½çš„é”™è¯¯ã€‚å¦‚æœè¯»å–å¤±è´¥ï¼Œç¨‹åºä¼šç»ˆæ­¢å¹¶æ˜¾ç¤ºæŒ‡å®šçš„é”™è¯¯ä¿¡æ¯ã€‚

`println!("You guessed: {}", guess);`

Uses theÂ `println!`Â macro again to print the user's input.Â `{}`Â is a placeholder that will be replaced by the value ofÂ `guess`.

å†æ¬¡ä½¿ç”¨ Â `println!`Â  å®ï¼Œæ‰“å°ç”¨æˆ·è¾“å…¥çš„å†…å®¹ã€‚`{}`Â  æ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼Œä¼šè¢« Â `guess`Â  çš„å€¼æ›¿æ¢ã€‚

### Randomly Generated éšæœºç”Ÿæˆ ğŸ²

Generate a random number between 1 and 100.

ç”Ÿæˆä¸€ä¸ª 1~100 ä¹‹é—´çš„éšæœºæ•°ã€‚

```toml
[dependencies]
rand = "0.8.4"
```

```rust
use rand::Rng;
use std::io;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    println!("The secret number is: {}", secret_number);
    println!("Please input your guessï¼š");
    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("You guessed: {}", guess);
}
```

`use rand:: Rng;`

The `rand::Rng` package is a `trait` in Rust. You can think of a trait as an interface that defines certain methods that types must implement. When you bring a `trait` into your code using `use`, itâ€™s similar to a class implementing an interface in other programming languages.

`rand::Rng` åŒ…æ˜¯ Rust ä¸­çš„ä¸€ä¸ª `trait`ã€‚ä½ å¯ä»¥æŠŠ `trait` æƒ³æˆä¸€ä¸ªæ¥å£ï¼Œå®ƒå®šä¹‰äº†æŸäº›æ–¹æ³•ï¼Œç±»å‹å¿…é¡»å®ç°è¿™äº›æ–¹æ³•ã€‚å½“ä½ ä½¿ç”¨ `use` å¼•å…¥ä¸€ä¸ª `trait` æ—¶ï¼Œè¿™ç±»ä¼¼äºå…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­ä¸€ä¸ªç±»å®ç°ä¸€ä¸ªæ¥å£ã€‚

`rand::thread_rng()`: This function creates a random number generator that is local to the current thread. It is a convenient way to generate random numbers in a thread-safe manner.

`rand::thread_rng()`ï¼šè¿™ä¸ªå‡½æ•°åˆ›å»ºä¸€ä¸ªä¸å½“å‰çº¿ç¨‹ç›¸å…³çš„éšæœºæ•°ç”Ÿæˆå™¨ã€‚è¿™æ˜¯ä¸€ç§æ–¹ä¾¿çš„æ–¹å¼ï¼Œå¯ä»¥åœ¨çº¿ç¨‹å®‰å…¨çš„æƒ…å†µä¸‹ç”Ÿæˆéšæœºæ•°ã€‚

`.gen_range(1..101)`: This method generates a random number within the specified range. The range `1..101` means that the generated number will be between 1 and 100, inclusive of 1 and exclusive of 101.

`.gen_range(1..101)`ï¼šè¿™ä¸ªæ–¹æ³•åœ¨æŒ‡å®šçš„èŒƒå›´å†…ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ã€‚èŒƒå›´ `1..101` æ„å‘³ç€ç”Ÿæˆçš„æ•°å­—å°†åœ¨ 1 åˆ° 100 ä¹‹é—´ï¼ŒåŒ…æ‹¬ 1ï¼Œä½†ä¸åŒ…æ‹¬ 101ã€‚

`let secret_number =`: This part declares a new variable named `secret_number` and assigns it the value generated by the random number generator.

`let secret_number =`ï¼šè¿™ä¸€éƒ¨åˆ†å£°æ˜äº†ä¸€ä¸ªåä¸º `secret_number` çš„æ–°å˜é‡ï¼Œå¹¶å°†éšæœºæ•°ç”Ÿæˆå™¨ç”Ÿæˆçš„å€¼èµ‹ç»™å®ƒã€‚

### Compare æ¯”è¾ƒ âš–

Compare the generated random number with the input number.

æ¯”è¾ƒç”Ÿæˆçš„éšæœºæ•°å’Œè¾“å…¥æ•°å­—ã€‚

```rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    // println!("The secret number is: {}", secret_number);
    println!("Please input your guessï¼š");
    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("You guessed: {}", guess);

    let guess: u32 = guess.trim().parse().expect("Please type a number!");
    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small"),
        Ordering::Greater => println!("Too big"),
        Ordering::Equal => println!("You win!"),
    }
}
```

`guess.trim()` removes spaces, tabs, and carriage returns (pressing `enter` while typing results in `\n` input)

`guess.trim()` ä¼šåˆ é™¤ç©ºæ ¼ã€tabã€ä»¥åŠå›è½¦ï¼ˆè¾“å…¥æ—¶å€™æŒ‰`å›è½¦`å°±ä¼šæœ‰ `\n` è¾“å…¥ï¼‰

`parse()` will parse the input string, there are `i32` `u32` `i64`, we choose to parse it as `u32`.

`parse()` ä¼šæŠŠè¾“å…¥çš„å­—ç¬¦ä¸²è§£æï¼Œæœ‰ `i32`Â `u32`Â `i64`ï¼Œæˆ‘ä»¬è¿™é‡Œé€‰æ‹©è§£ææˆ `u32`ã€‚

`.expect("Please type a number!")`: This method is called on the result of the `parse()` method. If the parsing is successful, it returns the parsed number. If it fails (for example, if the input is not a valid number), it will panic and display the message "Please type a number!".

`.expect("Please type a number!")`ï¼šè¿™ä¸ªæ–¹æ³•åœ¨ `parse()` æ–¹æ³•çš„ç»“æœä¸Šè°ƒç”¨ã€‚å¦‚æœè§£ææˆåŠŸï¼Œå®ƒè¿”å›è§£æåçš„æ•°å­—ã€‚å¦‚æœå¤±è´¥ï¼ˆä¾‹å¦‚ï¼Œè¾“å…¥ä¸æ˜¯æœ‰æ•ˆçš„æ•°å­—ï¼‰ï¼Œå®ƒå°†å¼•å‘ panicï¼Œå¹¶æ˜¾ç¤ºæ¶ˆæ¯ "Please type a number!"ã€‚

Ordering has three variants `Less`, `Greater`, `Equal`.

Ordering æœ‰ä¸‰ä¸ªå˜ä½“ `Less`ã€`Greater`ã€`Equal`ã€‚

`guess.cmp(&secret_number)` is to compare guess with secret_number, this method returns an Ordering.

`guess.cmp(&secret_number)` æ˜¯ç”¨ guess å’Œ secret_number è¿›è¡Œæ¯”è¾ƒï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª Orderingã€‚

### Final ç»ˆç‰ˆ ğŸ

Add loops until the rule is reached and then ends.

æ·»åŠ å¾ªç¯ç›´è‡³è¾¾åˆ°è§„åˆ™åç»“æŸã€‚

```rust
fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    // println!("The secret number is: {}", secret_number);
    loop {
        println!("Please input your guessï¼š");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        println!("You guessed: {}", guess);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small"),
            Ordering::Greater => println!("Too big"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
