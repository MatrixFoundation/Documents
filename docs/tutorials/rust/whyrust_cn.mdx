---
sidebar_label: Why Rust?
title: Why Rust?
sidebar_position: 2
---

## 一、初印象 🧐

一门赋予每个人构建可靠且高效软件能力的语言。

Rust 是区块链系统中最广泛使用的语言之一，许多流行的区块链包括 <u>Solana、Polkadot、Aptos 和 Sui</u> 都是用 Rust 构建的。诸如 <u>Foundry</u> 等 Rust 框架也受到包括以太坊在内的区块链开发人员的高度青睐。

Rust 的使用在区块链项目中正在迅速增长，越来越多的开发者和团队开始认识到其性能和安全性带来的优势。在未来几年，我们将看到这一趋势的指数级增长。

> [GitHub - rust-in-blockchain/awesome-blockchain-rust](https://github.com/rust-in-blockchain/awesome-blockchain-rust)

Rust 是一种现代编程语言，以其对安全性和性能的关注而声名远扬，值得我们所有开发者学习！

## 二、特点 ✨

### 1、安全 🛡

Rust 通过其创新的所有权模型确保内存安全，而无需垃圾收集器。

内存安全意味着该语言可以防止由于内存处理不当而导致崩溃或安全漏洞的错误。

Rust 的所有权模型确保变量在超出作用域时自动释放，防止内存泄漏和悬挂引用。

此外，Rust 的借用检查器强制执行对可变和不可变引用的严格规则，防止数据竞争和其他常见的并发错误。

### 2、高性能 🚀

Rust 提供了编译型语言的速度和无需垃圾收集器的手动内存管理效率，使其成为性能关键领域的理想选择。Rust 独特的“零成本抽象”使我们能够编写高性能且安全的代码，而无需经历额外的运行时开销。

:::info

垃圾收集涉及回收运行时不再使用的内存的自动化过程。简单来说，它是消除未使用对象的一种手段。垃圾收集的目的是防止程序超出其分配的内存容量或达到无法再正常运行的状态。此外，它还减轻了开发人员手动管理程序内存的负担，从而减少了出现内存相关错误的可能性。

相比之下，Rust 采用了一种独特的方法，放弃使用垃圾收集器。相反，它通过复杂而复杂的类型系统来实现这些目标。这种方法使 Rust 异常高效；然而，它也给 Rust 的学习和使用带来了更高程度的复杂性。

:::

### 3、并发 🤝

Rust 旨在使并发编程变得可访问和安全。它提供了诸如线程和异步编程之类的抽象，同时通过类型系统强制执行线程安全。

### 4、生态系统 🌍

Rust 的生态系统提供了丰富的库、工具和框架。

Cargo 包管理器简化了依赖项管理、编译和构建 Rust 项目的过程，培育了一个充满活力的生态系统，不断扩展语言的适用性。

此外，通过 FFI（外部函数接口）与各种语言的集成，有效地弥合了 Rust 系统级效率与高级脚本语言的易用性之间的鸿沟。

Rust 仍在不断发展壮大，其活跃的社区不断开发和维护适用于各种用例的库。你可以在 `crates.io` 上找到各种各样的库。

### 5、开源社区 🧑‍🤝‍🧑

Rust 拥有一个非常友好和充满活力的开源开发者社区。这个社区以其热情、包容和乐于助人而闻名。

## 三、Hello World 🧑‍

### 1、新建项目 ➕

`cargo new hello-rust`

### 2、项目文件结构 📁

```
hello-rust/
├── Cargo.toml
├── .gitignore
└── src/
    └── main.rs
```

- `Cargo.toml` 是 Rust 项目的核心配置文件，用于定义项目元数据、依赖关系和构建设置。

- `.gitignore` 文件用于指定在 Git 版本控制中应被忽略的文件和目录。

- `src/main.rs` 是我们要写应用程序代码的地方。

### 3、编写程序 ✍

```rust
fn main() {
    println!("Hello World");
}
```

在 Rust 中，每个可执行程序都必须包含一个名为  `main`  的函数作为入口点。

`println!("Hello World");`

这是一个宏调用，用于将文本输出到标准输出。

`println!`  是 Rust 标准库提供的宏之一，它在控制台打印一行文本，并自动在末尾添加换行符。对于  `println`  来说，我们没有使用其它语言惯用的  `%s`、`%d`  来做输出占位符，而是使用  `{}`，因为 Rust 在底层帮我们做了大量工作，会自动识别输出数据的类型。

### 4、运行代码 ▶️

`cargo run`

## 四、猜数游戏 🔢

在这个游戏中，计算机会随机生成一个数字，然后玩家需要猜测这个数字。每次猜测后，程序会告诉玩家猜的数字是太大、太小还是正确。通过这个过程，玩家可以逐步缩小范围，直到找到正确的数字。

### 1、输入/输出 📥/📤

输入一个数并输出。

```rust
use std::io;

fn main() {
    println!("Please input your guess：");
    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("You guessed: {}", guess);
}
```

`use std::io;`

这行代码导入了 Rust 标准库中的 input/output 模块，使我们能够使用输入输出相关的功能。

`fn main()`

定义了程序的主函数，程序的执行从这里开始。

`println!("Please input your guess：");`

使用  `println!`  宏在控制台打印一条提示信息，要求用户输入猜测。

`let mut guess = String::new();`

创建一个可变的  `String`  类型变量  `guess`，用于存储用户输入。`mut`  关键字表示这个变量是可变的。

`io::stdin()`

调用  `io`  模块的  `stdin`  函数，返回一个标准输入的句柄。

`.read_line(&mut guess)`

在标准输入句柄上调用  `read_line`  方法，读取用户输入的一行文本。`&mut guess`  是一个可变引用，表示将用户输入存储到  `guess`  变量中。

`.expect("Failed to read line");`

`read_line`  方法返回一个  `Result`  类型，`expect`  用于处理可能的错误。如果读取失败，程序会终止并显示指定的错误信息。

`println!("You guessed: {}", guess);`

再次使用  `println!`  宏，打印用户输入的内容。`{}`  是一个占位符，会被  `guess`  的值替换。

### 2、随机生成 🎲

生成一个 1~100 之间的随机数。

```toml
[dependencies]
rand = "0.8.4"
```

```rust
use rand::Rng;
use std::io;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    println!("The secret number is: {}", secret_number);
    println!("Please input your guess：");
    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("You guessed: {}", guess);
}
```

`use rand:: Rng;`

`rand::Rng` 包是 Rust 中的一个 `trait`。你可以把 `trait` 想成一个接口，它定义了某些方法，类型必须实现这些方法。当你使用 `use` 引入一个 `trait` 时，这类似于其他编程语言中一个类实现一个接口。

`rand::thread_rng()`：这个函数创建一个与当前线程相关的随机数生成器。这是一种方便的方式，可以在线程安全的情况下生成随机数。

`.gen_range(1..101)`：这个方法在指定的范围内生成一个随机数。范围 `1..101` 意味着生成的数字将在 1 到 100 之间，包括 1，但不包括 101。

`let secret_number =`：这一部分声明了一个名为 `secret_number` 的新变量，并将随机数生成器生成的值赋给它。

### 3、比较 ⚖

比较生成的随机数和输入数字。

```rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    // println!("The secret number is: {}", secret_number);
    println!("Please input your guess：");
    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
    println!("You guessed: {}", guess);

    let guess: u32 = guess.trim().parse().expect("Please type a number!");
    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small"),
        Ordering::Greater => println!("Too big"),
        Ordering::Equal => println!("You win!"),
    }
}
```

`guess.trim()` 会删除空格、tab、以及回车（输入时候按`回车`就会有 `\n` 输入）

`parse()` 会把输入的字符串解析，有 `i32` `u32` `i64`，我们这里选择解析成 `u32`。

`.expect("Please type a number!")`：这个方法在 `parse()` 方法的结果上调用。如果解析成功，它返回解析后的数字。如果失败（例如，输入不是有效的数字），它将引发 panic，并显示消息 "Please type a number!"。

Ordering 有三个变体 `Less`、`Greater`、`Equal`。

`guess.cmp(&secret_number)` 是用 guess 和 secret_number 进行比较，这个方法会返回一个 Ordering。

### 4、终版 🏁

添加循环直至达到规则后结束。

```rust
fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    // println!("The secret number is: {}", secret_number);
    loop {
        println!("Please input your guess：");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        println!("You guessed: {}", guess);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small"),
            Ordering::Greater => println!("Too big"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
